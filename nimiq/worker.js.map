{"version":3,"sources":["Class.js","LogNative.js","Log.js","IWorker.js","CryptoUtils.js","CryptoWorker.js","CryptoWorkerImpl.js","BigNumber.js","NumberUtils.js","BufferUtils.js","SerialBuffer.js","MinerWorker.js","MinerWorkerImpl.js","MinerWorkerPool.js","PlatformUtils.js","WasmHelper.js","GenesisConfig.js","ArrayUtils.js","Assert.js","MerkleTree.js","MerklePath.js","Policy.js","Serializable.js","Hash.js","PublicKey.js","Signature.js","Address.js","Account.js","PrunedAccount.js","BasicAccount.js","Contract.js","HashedTimeLockedContract.js","VestingContract.js","BlockHeader.js","BlockInterlink.js","BlockBody.js","BlockUtils.js","Block.js","Transaction.js","SignatureProof.js","BasicTransaction.js","ExtendedTransaction.js"],"names":["Class","scope","exports","self","window","[object Object]","cls","name","register","LogNative","this","_global_level","Log","INFO","_tag_levels","localStorage","c","getItem","JSON","parse","e","console","warn","tag","level","setItem","stringify","args","isLoggable","unshift","Level","toStringTag","Date","toTimeString","substr","error","ERROR","apply","WARNING","info","debug","DEBUG","trace","TRACE","log","instance","_instance","native","_native","setLoggable","get","l","i","length","toString","constructor","msg","message","arguments","Array","prototype","slice","call","undefined","VERBOSE","ASSERT","v","isNaN","parseInt","toLowerCase","d","bind","w","t","IWorker","clazz","worker","Proxy","workerScript","_workersSupported","Nimiq","_path","createProxy","Worker","URL","createObjectURL","Blob","replace","_workerImplementation","init","size","Pool","startWorkerForProxy","start","data","command","res","postMessage","status","result","id","areWorkersAsync","_insideWebWorker","WorkerGlobalScope","_global","global","baseClazz","impl","onmessage","stubBaseOnMessage","url","resolve","head","document","getElementsByTagName","script","createElement","type","src","ret","setTimeout","onreadystatechange","onload","appendChild","proxyClass","super","_name","_messageId","_worker","_receive","_waiting","Map","_invoke","then","cb","delete","WorkerProxy","Promise","obj","set","funcName","Object","getOwnPropertyNames","Stub","finalRes","_result","_onmessage","close","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","poolSize","_size","catch","push","shift","_step","indexOf","destroy","workerPromises","createdWorkers","all","pop","idx","splice","_moduleLoadedCallbacks","CryptoUtils","key","SHA512_BLOCK_SIZE","SerialBuffer","Hash","computeSha512","iKey","oKey","byte","innerHash","BufferUtils","concatTypedArrays","password","salt","iterations","derivedKeyLength","hashLength","SIZE","Algorithm","SHA512","Math","pow","Error","ceil","r","derivedKey","u","write","writeUint32","computeHmacSha512","j","k","CryptoWorker","getInstanceAsync","kdfLegacy","byteLength","xor","kdf","lib","CryptoLib","_workerAsync","startWorkerPoolForProxy","input","inputs","outputSize","block","transactionValid","timeNow","genesisHash","networkId","CryptoWorkerImpl","_superInit","PlatformUtils","isBrowser","WasmHelper","doImportBrowser","isNodeJs","out","Uint8Array","getSize","ARGON2D","NodeNative","node_argon2","stackPtr","Module","stackSave","hashSize","wasmOut","stackAlloc","wasmIn","HEAPU8","buffer","_nimiq_argon2","hash","stackRestore","hashes","stackTmp","node_kdf_legacy","wasmSalt","_nimiq_kdf_legacy","node_kdf","_nimiq_kdf","blockSerialized","GenesisConfig","GENESIS_HASH","unserialize","NETWORK_ID","Block","body","transactions","_valid","valid","_verify","header","interlinkHash","interlink","bodyHash","serialize","prepareForWorkerUse","globalObject","BigNumber","isNumeric","mathceil","mathfloor","floor","bignumberError","tooManyDigits","BASE","LOG_BASE","MAX_SAFE_INTEGER","POWS_TEN","SQRT_BASE","MAX","bitFloor","n","coeffToString","a","s","z","charCodeAt","compare","x","y","b","xc","yc","intCheck","min","max","isArray","isOdd","toExponential","str","charAt","toFixedPoint","len","zs","clone","configObject","div","convertBase","parseNumeric","random53bitInt","basePrefix","dotAfter","dotBefore","isInfinityOrNaN","whitespaceOrPlus","P","valueOf","ONE","DECIMAL_PLACES","ROUNDING_MODE","TO_EXP_NEG","TO_EXP_POS","MIN_EXP","MAX_EXP","CRYPTO","MODULO_MODE","POW_PRECISION","FORMAT","decimalSeparator","groupSeparator","groupSize","secondaryGroupSize","fractionGroupSeparator","fractionGroupSize","ALPHABET","alphabet","isNum","test","round","search","substring","format","rm","c0","ne","maxOrMin","method","m","normalise","sd","ni","rd","pows10","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","config","p","hasOwnProperty","crypto","getRandomValues","randomBytes","EXPONENTIAL_AT","RANGE","isBigNumber","_isBigNumber","maximum","lt","minimum","gt","random","dp","rand","Uint32Array","copy","toBaseOut","baseIn","baseOut","arrL","arr","reverse","sign","callerIsToString","concat","multiply","base","temp","xlo","xhi","carry","klo","khi","aL","bL","cmp","subtract","more","prod","prodL","q","qc","rem","remL","rem0","xi","xL","yc0","yL","yz","NaN","p1","p2","absoluteValue","abs","comparedTo","decimalPlaces","dividedBy","dividedToIntegerBy","idiv","exponentiatedBy","half","isModExp","nIsBig","nIsNeg","nIsOdd","isInteger","mod","times","integerValue","isEqualTo","eq","equals","isFinite","isGreaterThan","isGreaterThanOrEqualTo","gte","isLessThan","isLessThanOrEqualTo","lte","isNegative","isPositive","isZero","minus","xLTy","plus","xe","ye","modulo","multipliedBy","xcL","ycL","ylo","yhi","zc","sqrtBase","negated","precision","shiftedBy","squareRoot","sqrt","rep","toFixed","toFormat","split","g1","g2","intPart","fractionPart","isNeg","intDigits","RegExp","toFraction","md","d0","d1","d2","exp","n0","n1","toNumber","toPrecision","toJSON","NumberUtils","val","Number","UINT8_MAX","UINT16_MAX","UINT32_MAX","UINT64_MAX","bin","buf","_toUint8View","ascii","String","fromCharCode","subarray","string","TextDecoder","_ISO_8859_15_DECODER","uint8View","decode","num","_BASE64_LOOKUP","u8","end","tmp","output","_tripletToBase64","join","extraBytes","parts","len2","_base64encodeChunk","Buffer","from","btoa","_codePointTextDecoder","_base64fromByteArray","base64","atob","map","toBase64","fromBase64","BASE32_ALPHABET","NIMIQ","symbol","base32","charmap","toUpperCase","forEach","char","hex","code","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","lpad","TextEncoder","_UTF8_ENCODER","encode","_utf8TextEncoder","_strToUint8Array","o","EMPTY","fromHex","viewA","viewB","arrayLike","ArrayBuffer","BASE64_ALPHABET","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","_view","DataView","_readPos","_writePos","ArrayUtils","readPos","value","writePos","array","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","isUint64","readUint8","readUint16","readUint32","readUint64","writeUint8","writeUint16","writeUint64","getFloat64","setFloat64","bytes","read","toAscii","isMultibyte","fromAscii","view","byteOffset","padding","isUint8","MinerWorker","blockHeader","compact","minNonce","maxNonce","MinerWorkerImpl","_malloc","nonce","_nimiq_argon2_target","_free","MinerWorkerPool","_miningEnabled","_activeNonces","_block","_noncesPerRun","_observable","Observable","_shareCompact","Policy","BLOCK_TARGET_MAX","_runsPerCycle","Infinity","_cycleWait","_superUpdateToSize","cpuSupport","multiMine","fail","node_argon2_target_async","async","computeArgon2d","noncesPerRun","nonces","runsPerCycle","cycleWait","callback","on","off","shareCompact","nBits","_startMiner","nonceRange","_singleMiner","fire","newMin","newRange","RTCPeerConnection","webkitRTCPeerConnection","createDataChannel","location","protocol","navigator","onLine","platform","userAgentString","hardwareConcurrency","_importBrowserPromise","importWasmBrowser","importScriptBrowser","wasm","module","_adjustWasmPath","WebAssembly","xhr","XMLHttpRequest","open","responseType","wasmBinary","response","onerror","send","asm","_adjustScriptPath","moduleSettings","reject","runtimeInitialized","onRuntimeInitialized","importScripts","_loadBrowserScript","require","__dirname","uintarr","begin","clamp","list","indices","reverseRange","found","Assert","condition","MerkleTree","values","fnHash","_hash","_computeRoot","light","mid","left","right","leftHash","rightHash","MerklePath","nodes","some","it","MerklePathNode","_nodes","leafValue","leafHash","path","_compute","containsLeaf","inner","leftLeaf","rightLeaf","root","node","serializedSize","count","leftBitsSize","leftBits","_compress","reduce","sum","every","_left","coins","LUNAS_PER_COIN","lunas","coinsToLunas","satoshis","lunasToCoins","SATOSHIS_PER_COIN","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","remaining","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Serializable","toHex","arg","algorithm","BLAKE2B","_obj","_algorithm","blake2b","computeBlake2b","argon2d","computeSha256","SHA256","sha256","fromAny","fromString","node_blake2","_nimiq_blake2","node_sha256","_nimiq_sha256","node_sha512","_nimiq_sha512","hashAlgorithm","NULL","PublicKey","privateKey","_publicKeyDerive","publicKeys","sort","_delinearizeAndAggregatePublicKeys","Address","fromHash","PeerId","publicKeysObj","publicKeysHash","_publicKeysHash","raw","_publicKeysDelinearizeAndAggregate","PrivateKey","node_ed25519_public_key_derive","pubKeyBuffer","HEAP8","privKeyBuffer","_ed25519_public_key_derive","fill","publicKey","concatenatedPublicKeys","node_ed25519_hash_public_keys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","node_ed25519_delinearize_public_key","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_delinearize_public_key","delinearizedPublicKey","node_ed25519_aggregate_delinearized_public_keys","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","Signature","_signatureCreate","commitment","signatures","_combinePartialSignatures","_signatureVerify","combinedCommitment","partialSignatures","combinedSignature","_aggregatePartialSignatures","sigA","sigB","_scalarsAdd","PartialSignature","node_ed25519_add_scalars","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","node_ed25519_sign","wasmOutSignature","signatureBuffer","wasmInMessage","wasmInPubKey","wasmInPrivKey","_ed25519_sign","signature","node_ed25519_verify","wasmInSignature","_ed25519_verify","SERIALIZED_SIZE","addr","toUserFriendlyAddress","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","check","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","has","fromPlain","plain","Type","transaction","transactionsCache","revert","validityStartHeight","ValidityError","withBalance","fee","newBalance","BalanceError","containsTransaction","DoubleTransactionError","INITIAL","isInitial","proof","BASIC","VESTING","HTLC","ProofError","PrunedAccount","address","account","_address","_account","hashCode","toPlain","BasicAccount","SignatureProof","verifyTransaction","hasFlag","Transaction","Flag","recipientType","withIncomingTransaction","create","dataToPlain","signatureProof","signer","toAddress","pathLength","merklePath","proofToPlain","Contract","recipient","getContractCreationAddress","HashedTimeLockedContract","sender","hashRoot","hashCount","timeout","totalAmount","isUint32","_sender","_recipient","_hashRoot","_hashCount","_timeout","_totalAmount","ProofType","REGULAR_TRANSFER","hashDepth","preImage","compute","verify","serializeContent","EARLY_RESOLVE","TIMEOUT_RESOLVE","verifyIncomingTransaction","minCap","isSignedBy","withOutgoingTransaction","creatorSignatureProof","creator","creatorSignature","creatorPublicKey","creatorPathLength","proofType","VestingContract","owner","vestingStart","vestingStepBlocks","vestingStepAmount","vestingTotalAmount","_owner","_vestingStart","_vestingStepBlocks","_vestingStepAmount","_vestingTotalAmount","getMinCap","BlockHeader","prevHash","accountsHash","height","timestamp","version","CURRENT_VERSION","isUint16","isHash","BlockUtils","isValidCompact","_version","_prevHash","_interlinkHash","_bodyHash","_accountsHash","_nBits","_height","_timestamp","_nonce","SUPPORTED_VERSIONS","includes","isProofOfWork","target","prevHeader","_pow","hard","compactToTarget","difficulty","compactToDifficulty","Version","V1","BlockInterlink","repeatBitsSize","repeatBits","lastHash","compressed","_hashes","_repeatBits","_compressed","computeRoot","BlockBody","extraData","minerAddr","prunedAccounts","_minerAddr","_extraData","_transactions","_prunedAccounts","extraDataLength","numTransactions","numPrunedAccounts","tx","acc","previousTx","compareBlockOrder","previousAcc","isToBePruned","getMerkleLeafs","addresses","transactionCount","log2","getTargetHeight","targetToCompact","difficultyToTarget","targetToDifficulty","hashToTarget","getTargetDepth","isValidTarget","headBlock","tailBlock","deltaTotalDifficulty","that","actualTime","adjustment","averageDifficulty","nextTarget","_header","_interlink","_body","time","isLight","now","blockVerify","TIMESTAMP_DRIFT_MAX","verifyProofOfWork","_verifyInterlink","isFull","_verifyBody","predecessor","isImmediateSuccessorOf","getNextInterlink","prevPow","targetHeight","blockFound","depth","HashSet","addAll","removeAll","depthDiff","commonBlock","thisInterlink","prevInterlink","isInterlinkSuccessorOf","nextVersion","thisPowDepth","getHashDepth","nextTargetDepth","numOccurrences","h","pa","senderType","flags","_format","_senderType","_recipientType","_value","_fee","_networkId","_validityStartHeight","_flags","_data","_proof","FORMAT_MAP","serializedContentSize","verifyOutgoingTransaction","recCompare","senderCompare","transactionHash","Format","feePerByte","network","networkIdToNetworkName","flag","EXTENDED","NONE","ALL","signerKey","_publicKey","_merklePath","_signature","SINGLE_SIG_SIZE","merkleRoot","BasicTransaction","senderPubKey","singleSig","_signatureProof","networkIdFromAny","ExtendedTransaction","dataSize","proofSize"],"mappings":"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","file":"worker.js","sourcesContent":["class Class {\n    static get scope() {\n        if (typeof exports !== 'undefined') return exports;\n        if (typeof self !== 'undefined') return self;\n        return window;\n    }\n\n    static register(cls) {\n        if (typeof exports !== 'undefined') exports[cls.name] = cls;\n    }\n}\nClass.register(Class);\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n        try {\n            if (window.localStorage) {\n                try {\n                    let c = window.localStorage.getItem('log_tag_levels');\n                    if (c && typeof c === 'string') c = JSON.parse(c);\n                    if (c && typeof c === 'object') this._tag_levels = c;\n                } catch (e) {\n                    console.warn('Failed to load log configuration from local storage.');\n                }\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        if (this._tag_levels['*']) {\n            return this._tag_levels['*'] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        this._tag_levels[tag] = level;\n        if (window.localStorage) {\n            window.localStorage.setItem('log_tag_levels', JSON.stringify(this._tag_levels));\n        }\n    }\n\n    msg(level, tag, args) {\n        if (tag && tag.name) tag = tag.name;\n        if (!this.isLoggable(tag, level)) return;\n        if (tag) args.unshift(tag + ':');\n        args.unshift(`[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}]`);\n        if (console.error && level >= Log.ERROR) {\n            console.error.apply(console, args);\n        } else if (console.warn && level >= Log.WARNING) {\n            console.warn.apply(console, args);\n        } else if (console.info && level >= Log.INFO) {\n            console.info.apply(console, args);\n        } else if (console.debug && level >= Log.DEBUG) {\n            console.debug.apply(console, args);\n        } else if (console.trace && level <= Log.TRACE) {\n            console.trace.apply(console, args);\n        } else {\n            console.log.apply(console, args);\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, Log.Level.get(level));\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = Log.Level.get(l);\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n\n/**\n * @enum {number|string}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     * @returns {string}\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'T';\n            case Log.Level.VERBOSE:\n                return 'V';\n            case Log.Level.DEBUG:\n                return 'D';\n            case Log.Level.INFO:\n                return 'I';\n            case Log.Level.WARNING:\n                return 'W';\n            case Log.Level.ERROR:\n                return 'E';\n            case Log.Level.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    },\n\n    toString: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'trace';\n            case Log.Level.VERBOSE:\n                return 'verbose';\n            case Log.Level.DEBUG:\n                return 'debug';\n            case Log.Level.INFO:\n                return 'info';\n            case Log.Level.WARNING:\n                return 'warn';\n            case Log.Level.ERROR:\n                return 'error';\n            case Log.Level.ASSERT:\n                return 'assert';\n            default:\n                return 'unknown';\n        }\n    },\n\n    /**\n     * @param {string|number|Log.Level} v\n     * @returns {Log.Level}\n     */\n    get: function (v) {\n        if (typeof v === 'number') return /** @type {Log.Level} */ v;\n        if (!isNaN(parseInt(v))) return /** @type {Log.Level} */ parseInt(v);\n        switch (v.toLowerCase()) {\n            case 't':\n            case 'trace':\n                return Log.Level.TRACE;\n            case 'v':\n            case 'verbose':\n                return Log.Level.VERBOSE;\n            case 'd':\n            case 'debug':\n                return Log.Level.DEBUG;\n            case 'i':\n            case 'info':\n                return Log.Level.INFO;\n            case 'w':\n            case 'warn':\n            case 'warning':\n                return Log.Level.WARNING;\n            case 'e':\n            case 'error':\n            case 'exception':\n                return Log.Level.ERROR;\n            case 'a':\n            case 'assert':\n            case 'assertion':\n                return Log.Level.ASSERT;\n        }\n        return /** @type {Log.Level} */ 0;\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","class CryptoUtils {\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} data\n     * @return {Uint8Array}\n     */\n    static computeHmacSha512(key, data) {\n        if (key.length > CryptoUtils.SHA512_BLOCK_SIZE) {\n            key = new SerialBuffer(Hash.computeSha512(key));\n        }\n\n        const iKey = new SerialBuffer(CryptoUtils.SHA512_BLOCK_SIZE);\n        const oKey = new SerialBuffer(CryptoUtils.SHA512_BLOCK_SIZE);\n        for (let i = 0; i < CryptoUtils.SHA512_BLOCK_SIZE; ++i) {\n            const byte = key[i] || 0;\n            iKey[i] = 0x36 ^ byte;\n            oKey[i] = 0x5c ^ byte;\n        }\n\n        const innerHash = Hash.computeSha512(BufferUtils.concatTypedArrays(iKey, data));\n        return Hash.computeSha512(BufferUtils.concatTypedArrays(oKey, innerHash));\n    }\n\n    /**\n     * @param {Uint8Array} password\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @param {number} derivedKeyLength\n     * @return {SerialBuffer}\n     */\n    static computePBKDF2sha512(password, salt, iterations, derivedKeyLength) {\n        // Following https://www.ietf.org/rfc/rfc2898.txt\n        const hashLength = Hash.SIZE.get(Hash.Algorithm.SHA512);\n\n        if (derivedKeyLength > (Math.pow(2, 32) - 1) * hashLength) {\n            throw new Error('Derived key too long');\n        }\n\n        const l = Math.ceil(derivedKeyLength / hashLength);\n        const r = derivedKeyLength - (l - 1) * hashLength;\n\n        const derivedKey = new SerialBuffer(derivedKeyLength);\n        for (let i = 1; i <= l; i++) {\n            let u = new SerialBuffer(salt.length + 4);\n            u.write(salt);\n            u.writeUint32(i);\n\n            u = CryptoUtils.computeHmacSha512(password, u);\n            const t = u;\n            for (let j = 1; j < iterations; j++) {\n                u = CryptoUtils.computeHmacSha512(password, u);\n                for (let k = 0; k < t.length; k++) {\n                    t[k] ^= u[k];\n                }\n            }\n\n            if (i < l) {\n                derivedKey.write(t);\n            } else {\n                derivedKey.write(t.slice(0, r));\n            }\n        }\n        return derivedKey;\n    }\n\n    /**\n     * @param {Uint8Array} message\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @return {Promise.<Uint8Array>}\n     * @deprecated\n     */\n    static async otpKdfLegacy(message, key, salt, iterations) {\n        const worker = await CryptoWorker.getInstanceAsync();\n        const derivedKey = await worker.kdfLegacy(key, salt, iterations, message.byteLength);\n        return BufferUtils.xor(message, derivedKey);\n    }\n\n    /**\n     * @param {Uint8Array} message\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @return {Promise.<Uint8Array>}\n     */\n    static async otpKdf(message, key, salt, iterations) {\n        const worker = await CryptoWorker.getInstanceAsync();\n        const derivedKey = await worker.kdf(key, salt, iterations, message.byteLength);\n        return BufferUtils.xor(message, derivedKey);\n    }\n\n}\nCryptoUtils.SHA512_BLOCK_SIZE = 128;\n\nClass.register(CryptoUtils);\n","/**\n * @interface\n */\nclass CryptoWorker {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     */\n    static async getInstanceAsync() {\n        if (!CryptoWorker._workerAsync) {\n            CryptoWorker._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return CryptoWorker._workerAsync;\n    }\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @param {number} outputSize\n     * @returns {Promise.<Uint8Array>}\n     * @deprecated\n     */\n    async kdfLegacy(key, salt, iterations, outputSize) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @param {number} outputSize\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations, outputSize) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash, networkId) {}\n}\n/** @type {CryptoWorker} */\nCryptoWorker._workerAsync = null;\n\nClass.register(CryptoWorker);\n","class CryptoWorkerImpl extends IWorker.Stub(CryptoWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        if (PlatformUtils.isBrowser()) await WasmHelper.doImportBrowser();\n        CryptoWorker._workerAsync = this;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeArgon2d(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Array.<Uint8Array>}\n     */\n    computeArgon2dBatch(inputs) {\n        const hashes = [];\n        if (PlatformUtils.isNodeJs()) {\n            for(const input of inputs) {\n                const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n                const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                hashes.push(out);\n            }\n            return hashes;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const stackTmp = Module.stackSave();\n                for (const input of inputs) {\n                    Module.stackRestore(stackTmp);\n                    const wasmIn = Module.stackAlloc(input.length);\n                    new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                    const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                    if (res !== 0) {\n                        throw res;\n                    }\n                    const hash = new Uint8Array(hashSize);\n                    hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                    hashes.push(hash);\n                }\n                return hashes;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @param {number} outputSize\n     * @returns {Uint8Array}\n     * @deprecated\n     */\n    kdfLegacy(key, salt, iterations, outputSize = Hash.getSize(Hash.Algorithm.ARGON2D)) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(outputSize);\n            const res = NodeNative.node_kdf_legacy(out, new Uint8Array(key), new Uint8Array(salt), 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(outputSize);\n                const wasmIn = Module.stackAlloc(key.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n                const wasmSalt = Module.stackAlloc(salt.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n                const res = Module._nimiq_kdf_legacy(wasmOut, outputSize, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(outputSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, outputSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @param {number} outputSize\n     * @returns {Uint8Array}\n     */\n    kdf(key, salt, iterations, outputSize = Hash.getSize(Hash.Algorithm.ARGON2D)) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(outputSize);\n            const res = NodeNative.node_kdf(out, new Uint8Array(key), new Uint8Array(salt), 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(outputSize);\n                const wasmIn = Module.stackAlloc(key.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n                const wasmSalt = Module.stackAlloc(salt.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n                const res = Module._nimiq_kdf(wasmOut, outputSize, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(outputSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, outputSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} blockSerialized\n     * @param {Array.<boolean|undefined>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(blockSerialized, transactionValid, timeNow, genesisHash, networkId) {\n        // The worker only uses a stub genesis config.\n        GenesisConfig = {\n            GENESIS_HASH: Hash.unserialize(new SerialBuffer(genesisHash)),\n            NETWORK_ID: networkId\n        };\n\n        const block = Block.unserialize(new SerialBuffer(blockSerialized));\n        for (let i = 0; i < transactionValid.length; i++) {\n            block.body.transactions[i]._valid = transactionValid[i];\n        }\n\n        const valid = await block._verify(timeNow);\n        const pow = await block.header.pow();\n        const interlinkHash = block.interlink.hash();\n        const bodyHash = block.body.hash();\n        return { valid: valid, pow: pow.serialize(), interlinkHash: interlinkHash.serialize(), bodyHash: bodyHash.serialize() };\n    }\n}\n\nIWorker.prepareForWorkerUse(CryptoWorker, new CryptoWorkerImpl());\n",";(function (globalObject) {\n    'use strict';\n\n    /*\n     *      bignumber.js v7.0.1\n     *      A JavaScript library for arbitrary-precision arithmetic.\n     *      https://github.com/MikeMcl/bignumber.js\n     *      Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\n     *      MIT Licensed.\n     *\n     *      BigNumber.prototype methods     |  BigNumber methods\n     *                                      |\n     *      absoluteValue            abs    |  clone\n     *      comparedTo                      |  config               set\n     *      decimalPlaces            dp     |      DECIMAL_PLACES\n     *      dividedBy                div    |      ROUNDING_MODE\n     *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\n     *      exponentiatedBy          pow    |      RANGE\n     *      integerValue                    |      CRYPTO\n     *      isEqualTo                eq     |      MODULO_MODE\n     *      isFinite                        |      POW_PRECISION\n     *      isGreaterThan            gt     |      FORMAT\n     *      isGreaterThanOrEqualTo   gte    |      ALPHABET\n     *      isInteger                       |  isBigNumber\n     *      isLessThan               lt     |  maximum              max\n     *      isLessThanOrEqualTo      lte    |  minimum              min\n     *      isNaN                           |  random\n     *      isNegative                      |\n     *      isPositive                      |\n     *      isZero                          |\n     *      minus                           |\n     *      modulo                   mod    |\n     *      multipliedBy             times  |\n     *      negated                         |\n     *      plus                            |\n     *      precision                sd     |\n     *      shiftedBy                       |\n     *      squareRoot               sqrt   |\n     *      toExponential                   |\n     *      toFixed                         |\n     *      toFormat                        |\n     *      toFraction                      |\n     *      toJSON                          |\n     *      toNumber                        |\n     *      toPrecision                     |\n     *      toString                        |\n     *      valueOf                         |\n     *\n     */\n\n\n    var BigNumber,\n        isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\n\n        mathceil = Math.ceil,\n        mathfloor = Math.floor,\n\n        bignumberError = '[BigNumber Error] ',\n        tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\n\n        BASE = 1e14,\n        LOG_BASE = 14,\n        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\n        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\n        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\n        SQRT_BASE = 1e7,\n\n        // EDITABLE\n        // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\n        // the arguments to toExponential, toFixed, toFormat, and toPrecision.\n        MAX = 1E9;                                   // 0 to MAX_INT32\n\n\n    /*\n     * Create and return a BigNumber constructor.\n     */\n    function clone(configObject) {\n        var div, convertBase, parseNumeric,\n            P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\n            ONE = new BigNumber(1),\n\n\n            //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\n\n\n            // The default values below must be integers within the inclusive ranges stated.\n            // The values can also be changed at run-time using BigNumber.set.\n\n            // The maximum number of decimal places for operations involving division.\n            DECIMAL_PLACES = 20,                     // 0 to MAX\n\n            // The rounding mode used when rounding to the above decimal places, and when using\n            // toExponential, toFixed, toFormat and toPrecision, and round (default value).\n            // UP         0 Away from zero.\n            // DOWN       1 Towards zero.\n            // CEIL       2 Towards +Infinity.\n            // FLOOR      3 Towards -Infinity.\n            // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n            // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n            // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n            // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n            // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n            ROUNDING_MODE = 4,                       // 0 to 8\n\n            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n\n            // The exponent value at and beneath which toString returns exponential notation.\n            // Number type: -7\n            TO_EXP_NEG = -7,                         // 0 to -MAX\n\n            // The exponent value at and above which toString returns exponential notation.\n            // Number type: 21\n            TO_EXP_POS = 21,                         // 0 to MAX\n\n            // RANGE : [MIN_EXP, MAX_EXP]\n\n            // The minimum exponent value, beneath which underflow to zero occurs.\n            // Number type: -324  (5e-324)\n            MIN_EXP = -1e7,                          // -1 to -MAX\n\n            // The maximum exponent value, above which overflow to Infinity occurs.\n            // Number type:  308  (1.7976931348623157e+308)\n            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\n            MAX_EXP = 1e7,                           // 1 to MAX\n\n            // Whether to use cryptographically-secure random number generation, if available.\n            CRYPTO = false,                          // true or false\n\n            // The modulo mode used when calculating the modulus: a mod n.\n            // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n            // The remainder (r) is calculated as: r = a - n * q.\n            //\n            // UP        0 The remainder is positive if the dividend is negative, else is negative.\n            // DOWN      1 The remainder has the same sign as the dividend.\n            //             This modulo mode is commonly known as 'truncated division' and is\n            //             equivalent to (a % n) in JavaScript.\n            // FLOOR     3 The remainder has the same sign as the divisor (Python %).\n            // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\n            // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\n            //             The remainder is always positive.\n            //\n            // The truncated division, floored division, Euclidian division and IEEE 754 remainder\n            // modes are commonly used for the modulus operation.\n            // Although the other rounding modes can also be used, they may not give useful results.\n            MODULO_MODE = 1,                         // 0 to 9\n\n            // The maximum number of significant digits of the result of the exponentiatedBy operation.\n            // If POW_PRECISION is 0, there will be unlimited significant digits.\n            POW_PRECISION = 0,                    // 0 to MAX\n\n            // The format specification used by the BigNumber.prototype.toFormat method.\n            FORMAT = {\n                decimalSeparator: '.',\n                groupSeparator: ',',\n                groupSize: 3,\n                secondaryGroupSize: 0,\n                fractionGroupSeparator: '\\xA0',      // non-breaking space\n                fractionGroupSize: 0\n            },\n\n            // The alphabet used for base conversion.\n            // It must be at least 2 characters long, with no '.' or repeated character.\n            // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n            ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';\n\n\n        //------------------------------------------------------------------------------------------\n\n\n        // CONSTRUCTOR\n\n\n        /*\n         * The BigNumber constructor and exported function.\n         * Create and return a new instance of a BigNumber object.\n         *\n         * n {number|string|BigNumber} A numeric value.\n         * [b] {number} The base of n. Integer, 2 to ALPHABET.length inclusive.\n         */\n        function BigNumber(n, b) {\n            var alphabet, c, e, i, isNum, len, str,\n                x = this;\n\n            // Enable constructor usage without new.\n            if (!(x instanceof BigNumber)) {\n\n                // Don't throw on constructor call without new (#81).\n                // '[BigNumber Error] Constructor call without new: {n}'\n                //throw Error(bignumberError + ' Constructor call without new: ' + n);\n                return new BigNumber(n, b);\n            }\n\n            if (b == null) {\n\n                // Duplicate.\n                if (n instanceof BigNumber) {\n                    x.s = n.s;\n                    x.e = n.e;\n                    x.c = (n = n.c) ? n.slice() : n;\n                    return;\n                }\n\n                isNum = typeof n == 'number';\n\n                if (isNum && n * 0 == 0) {\n\n                    // Use `1 / n` to handle minus zero also.\n                    x.s = 1 / n < 0 ? (n = -n, -1) : 1;\n\n                    // Faster path for integers.\n                    if (n === ~~n) {\n                        for (e = 0, i = n; i >= 10; i /= 10, e++);\n                        x.e = e;\n                        x.c = [n];\n                        return;\n                    }\n\n                    str = n + '';\n                } else {\n                    if (!isNumeric.test(str = n + '')) return parseNumeric(x, str, isNum);\n                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\n                }\n\n            } else {\n\n                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n                intCheck(b, 2, ALPHABET.length, 'Base');\n                str = n + '';\n\n                // Allow exponential notation to be used with base 10 argument, while\n                // also rounding to DECIMAL_PLACES as with other bases.\n                if (b == 10) {\n                    x = new BigNumber(n instanceof BigNumber ? n : str);\n                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\n                }\n\n                isNum = typeof n == 'number';\n\n                if (isNum) {\n\n                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.\n                    if (n * 0 != 0) return parseNumeric(x, str, isNum, b);\n\n                    x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;\n\n                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                    if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\n                        throw Error\n                        (tooManyDigits + n);\n                    }\n\n                    // Prevent later check for length on converted number.\n                    isNum = false;\n                } else {\n                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\n\n                    // Allow e.g. hexadecimal 'FF' as well as 'ff'.\n                    if (b > 10 && b < 37) str = str.toLowerCase();\n                }\n\n                alphabet = ALPHABET.slice(0, b);\n                e = i = 0;\n\n                // Check that str is a valid base b number.\n                // Don't use RegExp so alphabet can contain special characters.\n                for (len = str.length; i < len; i++) {\n                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {\n                        if (c == '.') {\n\n                            // If '.' is not the first character and it has not be found before.\n                            if (i > e) {\n                                e = len;\n                                continue;\n                            }\n                        }\n\n                        return parseNumeric(x, n + '', isNum, b);\n                    }\n                }\n\n                str = convertBase(str, b, 10, x.s);\n            }\n\n            // Decimal point?\n            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\n\n            // Exponential form?\n            if ((i = str.search(/e/i)) > 0) {\n\n                // Determine exponent.\n                if (e < 0) e = i;\n                e += +str.slice(i + 1);\n                str = str.substring(0, i);\n            } else if (e < 0) {\n\n                // Integer.\n                e = str.length;\n            }\n\n            // Determine leading zeros.\n            for (i = 0; str.charCodeAt(i) === 48; i++);\n\n            // Determine trailing zeros.\n            for (len = str.length; str.charCodeAt(--len) === 48;);\n\n            str = str.slice(i, ++len);\n\n            if (str) {\n                len -= i;\n\n                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                if (isNum && BigNumber.DEBUG &&\n                    len > 15 && (n > MAX_SAFE_INTEGER || n !== mathfloor(n))) {\n                    throw Error\n                    (tooManyDigits + (x.s * n));\n                }\n\n                e = e - i - 1;\n\n                // Overflow?\n                if (e > MAX_EXP) {\n\n                    // Infinity.\n                    x.c = x.e = null;\n\n                    // Underflow?\n                } else if (e < MIN_EXP) {\n\n                    // Zero.\n                    x.c = [x.e = 0];\n                } else {\n                    x.e = e;\n                    x.c = [];\n\n                    // Transform base\n\n                    // e is the base 10 exponent.\n                    // i is where to slice str to get the first element of the coefficient array.\n                    i = (e + 1) % LOG_BASE;\n                    if (e < 0) i += LOG_BASE;\n\n                    if (i < len) {\n                        if (i) x.c.push(+str.slice(0, i));\n\n                        for (len -= LOG_BASE; i < len;) {\n                            x.c.push(+str.slice(i, i += LOG_BASE));\n                        }\n\n                        str = str.slice(i);\n                        i = LOG_BASE - str.length;\n                    } else {\n                        i -= len;\n                    }\n\n                    for (; i--; str += '0');\n                    x.c.push(+str);\n                }\n            } else {\n\n                // Zero.\n                x.c = [x.e = 0];\n            }\n        }\n\n\n        // CONSTRUCTOR PROPERTIES\n\n\n        BigNumber.clone = clone;\n\n        BigNumber.ROUND_UP = 0;\n        BigNumber.ROUND_DOWN = 1;\n        BigNumber.ROUND_CEIL = 2;\n        BigNumber.ROUND_FLOOR = 3;\n        BigNumber.ROUND_HALF_UP = 4;\n        BigNumber.ROUND_HALF_DOWN = 5;\n        BigNumber.ROUND_HALF_EVEN = 6;\n        BigNumber.ROUND_HALF_CEIL = 7;\n        BigNumber.ROUND_HALF_FLOOR = 8;\n        BigNumber.EUCLID = 9;\n\n\n        /*\n         * Configure infrequently-changing library-wide settings.\n         *\n         * Accept an object with the following optional properties (if the value of a property is\n         * a number, it must be an integer within the inclusive range stated):\n         *\n         *   DECIMAL_PLACES   {number}           0 to MAX\n         *   ROUNDING_MODE    {number}           0 to 8\n         *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\n         *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\n         *   CRYPTO           {boolean}          true or false\n         *   MODULO_MODE      {number}           0 to 9\n         *   POW_PRECISION       {number}           0 to MAX\n         *   ALPHABET         {string}           A string of two or more unique characters, and not\n         *                                       containing '.'. The empty string, null or undefined\n         *                                       resets the alphabet to its default value.\n         *   FORMAT           {object}           An object with some of the following properties:\n         *      decimalSeparator       {string}\n         *      groupSeparator         {string}\n         *      groupSize              {number}\n         *      secondaryGroupSize     {number}\n         *      fractionGroupSeparator {string}\n         *      fractionGroupSize      {number}\n         *\n         * (The values assigned to the above FORMAT object properties are not checked for validity.)\n         *\n         * E.g.\n         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\n         *\n         * Ignore properties/parameters set to null or undefined, except for ALPHABET.\n         *\n         * Return an object with the properties current values.\n         */\n        BigNumber.config = BigNumber.set = function (obj) {\n            var p, v;\n\n            if (obj != null) {\n\n                if (typeof obj == 'object') {\n\n                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\n                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\n                        v = obj[p];\n                        intCheck(v, 0, MAX, p);\n                        DECIMAL_PLACES = v;\n                    }\n\n                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\n                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\n                        v = obj[p];\n                        intCheck(v, 0, 8, p);\n                        ROUNDING_MODE = v;\n                    }\n\n                    // EXPONENTIAL_AT {number|number[]}\n                    // Integer, -MAX to MAX inclusive or\n                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\n                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\n                        v = obj[p];\n                        if (isArray(v)) {\n                            intCheck(v[0], -MAX, 0, p);\n                            intCheck(v[1], 0, MAX, p);\n                            TO_EXP_NEG = v[0];\n                            TO_EXP_POS = v[1];\n                        } else {\n                            intCheck(v, -MAX, MAX, p);\n                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\n                        }\n                    }\n\n                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\n                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\n                    if (obj.hasOwnProperty(p = 'RANGE')) {\n                        v = obj[p];\n                        if (isArray(v)) {\n                            intCheck(v[0], -MAX, -1, p);\n                            intCheck(v[1], 1, MAX, p);\n                            MIN_EXP = v[0];\n                            MAX_EXP = v[1];\n                        } else {\n                            intCheck(v, -MAX, MAX, p);\n                            if (v) {\n                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\n                            } else {\n                                throw Error\n                                (bignumberError + p + ' cannot be zero: ' + v);\n                            }\n                        }\n                    }\n\n                    // CRYPTO {boolean} true or false.\n                    // '[BigNumber Error] CRYPTO not true or false: {v}'\n                    // '[BigNumber Error] crypto unavailable'\n                    if (obj.hasOwnProperty(p = 'CRYPTO')) {\n                        v = obj[p];\n                        if (v === !!v) {\n                            if (v) {\n                                if (typeof crypto != 'undefined' && crypto &&\n                                    (crypto.getRandomValues || crypto.randomBytes)) {\n                                    CRYPTO = v;\n                                } else {\n                                    CRYPTO = !v;\n                                    throw Error\n                                    (bignumberError + 'crypto unavailable');\n                                }\n                            } else {\n                                CRYPTO = v;\n                            }\n                        } else {\n                            throw Error\n                            (bignumberError + p + ' not true or false: ' + v);\n                        }\n                    }\n\n                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.\n                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\n                        v = obj[p];\n                        intCheck(v, 0, 9, p);\n                        MODULO_MODE = v;\n                    }\n\n                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.\n                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\n                        v = obj[p];\n                        intCheck(v, 0, MAX, p);\n                        POW_PRECISION = v;\n                    }\n\n                    // FORMAT {object}\n                    // '[BigNumber Error] FORMAT not an object: {v}'\n                    if (obj.hasOwnProperty(p = 'FORMAT')) {\n                        v = obj[p];\n                        if (typeof v == 'object') FORMAT = v;\n                        else throw Error\n                        (bignumberError + p + ' not an object: ' + v);\n                    }\n\n                    // ALPHABET {string}\n                    // '[BigNumber Error] ALPHABET invalid: {v}'\n                    if (obj.hasOwnProperty(p = 'ALPHABET')) {\n                        v = obj[p];\n\n                        // Disallow if only one character, or contains '.' or a repeated character.\n                        if (typeof v == 'string' && !/^.$|\\.|(.).*\\1/.test(v)) {\n                            ALPHABET = v;\n                        } else {\n                            throw Error\n                            (bignumberError + p + ' invalid: ' + v);\n                        }\n                    }\n\n                } else {\n\n                    // '[BigNumber Error] Object expected: {v}'\n                    throw Error\n                    (bignumberError + 'Object expected: ' + obj);\n                }\n            }\n\n            return {\n                DECIMAL_PLACES: DECIMAL_PLACES,\n                ROUNDING_MODE: ROUNDING_MODE,\n                EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\n                RANGE: [MIN_EXP, MAX_EXP],\n                CRYPTO: CRYPTO,\n                MODULO_MODE: MODULO_MODE,\n                POW_PRECISION: POW_PRECISION,\n                FORMAT: FORMAT,\n                ALPHABET: ALPHABET\n            };\n        };\n\n\n        /*\n         * Return true if v is a BigNumber instance, otherwise return false.\n         *\n         * v {any}\n         */\n        BigNumber.isBigNumber = function (v) {\n            return v instanceof BigNumber || v && v._isBigNumber === true || false;\n        };\n\n\n        /*\n         * Return a new BigNumber whose value is the maximum of the arguments.\n         *\n         * arguments {number|string|BigNumber}\n         */\n        BigNumber.maximum = BigNumber.max = function () {\n            return maxOrMin(arguments, P.lt);\n        };\n\n\n        /*\n         * Return a new BigNumber whose value is the minimum of the arguments.\n         *\n         * arguments {number|string|BigNumber}\n         */\n        BigNumber.minimum = BigNumber.min = function () {\n            return maxOrMin(arguments, P.gt);\n        };\n\n\n        /*\n         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\n         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\n         * zeros are produced).\n         *\n         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\n         * '[BigNumber Error] crypto unavailable'\n         */\n        BigNumber.random = (function () {\n            var pow2_53 = 0x20000000000000;\n\n            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\n            // Check if Math.random() produces more than 32 bits of randomness.\n            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\n            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\n            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\n                ? function () { return mathfloor(Math.random() * pow2_53); }\n                : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\n                    (Math.random() * 0x800000 | 0); };\n\n            return function (dp) {\n                var a, b, e, k, v,\n                    i = 0,\n                    c = [],\n                    rand = new BigNumber(ONE);\n\n                if (dp == null) dp = DECIMAL_PLACES;\n                else intCheck(dp, 0, MAX);\n\n                k = mathceil(dp / LOG_BASE);\n\n                if (CRYPTO) {\n\n                    // Browsers supporting crypto.getRandomValues.\n                    if (crypto.getRandomValues) {\n\n                        a = crypto.getRandomValues(new Uint32Array(k *= 2));\n\n                        for (; i < k;) {\n\n                            // 53 bits:\n                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\n                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\n                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\n                            //                                     11111 11111111 11111111\n                            // 0x20000 is 2^21.\n                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\n\n                            // Rejection sampling:\n                            // 0 <= v < 9007199254740992\n                            // Probability that v >= 9e15, is\n                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\n                            if (v >= 9e15) {\n                                b = crypto.getRandomValues(new Uint32Array(2));\n                                a[i] = b[0];\n                                a[i + 1] = b[1];\n                            } else {\n\n                                // 0 <= v <= 8999999999999999\n                                // 0 <= (v % 1e14) <= 99999999999999\n                                c.push(v % 1e14);\n                                i += 2;\n                            }\n                        }\n                        i = k / 2;\n\n                        // Node.js supporting crypto.randomBytes.\n                    } else if (crypto.randomBytes) {\n\n                        // buffer\n                        a = crypto.randomBytes(k *= 7);\n\n                        for (; i < k;) {\n\n                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\n                            // 0x100000000 is 2^32, 0x1000000 is 2^24\n                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\n                            // 0 <= v < 9007199254740992\n                            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\n                                (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\n                                (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\n\n                            if (v >= 9e15) {\n                                crypto.randomBytes(7).copy(a, i);\n                            } else {\n\n                                // 0 <= (v % 1e14) <= 99999999999999\n                                c.push(v % 1e14);\n                                i += 7;\n                            }\n                        }\n                        i = k / 7;\n                    } else {\n                        CRYPTO = false;\n                        throw Error\n                        (bignumberError + 'crypto unavailable');\n                    }\n                }\n\n                // Use Math.random.\n                if (!CRYPTO) {\n\n                    for (; i < k;) {\n                        v = random53bitInt();\n                        if (v < 9e15) c[i++] = v % 1e14;\n                    }\n                }\n\n                k = c[--i];\n                dp %= LOG_BASE;\n\n                // Convert trailing digits to zeros according to dp.\n                if (k && dp) {\n                    v = POWS_TEN[LOG_BASE - dp];\n                    c[i] = mathfloor(k / v) * v;\n                }\n\n                // Remove trailing elements which are zero.\n                for (; c[i] === 0; c.pop(), i--);\n\n                // Zero?\n                if (i < 0) {\n                    c = [e = 0];\n                } else {\n\n                    // Remove leading elements which are zero and adjust exponent accordingly.\n                    for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\n\n                    // Count the digits of the first element of c to determine leading zeros, and...\n                    for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\n\n                    // adjust the exponent accordingly.\n                    if (i < LOG_BASE) e -= LOG_BASE - i;\n                }\n\n                rand.e = e;\n                rand.c = c;\n                return rand;\n            };\n        })();\n\n\n        // PRIVATE FUNCTIONS\n\n\n        // Called by BigNumber and BigNumber.prototype.toString.\n        convertBase = (function () {\n            var decimal = '0123456789';\n\n            /*\n             * Convert string of baseIn to an array of numbers of baseOut.\n             * Eg. toBaseOut('255', 10, 16) returns [15, 15].\n             * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\n             */\n            function toBaseOut(str, baseIn, baseOut, alphabet) {\n                var j,\n                    arr = [0],\n                    arrL,\n                    i = 0,\n                    len = str.length;\n\n                for (; i < len;) {\n                    for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\n\n                    arr[0] += alphabet.indexOf(str.charAt(i++));\n\n                    for (j = 0; j < arr.length; j++) {\n\n                        if (arr[j] > baseOut - 1) {\n                            if (arr[j + 1] == null) arr[j + 1] = 0;\n                            arr[j + 1] += arr[j] / baseOut | 0;\n                            arr[j] %= baseOut;\n                        }\n                    }\n                }\n\n                return arr.reverse();\n            }\n\n            // Convert a numeric string of baseIn to a numeric string of baseOut.\n            // If the caller is toString, we are converting from base 10 to baseOut.\n            // If the caller is BigNumber, we are converting from baseIn to base 10.\n            return function (str, baseIn, baseOut, sign, callerIsToString) {\n                var alphabet, d, e, k, r, x, xc, y,\n                    i = str.indexOf('.'),\n                    dp = DECIMAL_PLACES,\n                    rm = ROUNDING_MODE;\n\n                // Non-integer.\n                if (i >= 0) {\n                    k = POW_PRECISION;\n\n                    // Unlimited precision.\n                    POW_PRECISION = 0;\n                    str = str.replace('.', '');\n                    y = new BigNumber(baseIn);\n                    x = y.pow(str.length - i);\n                    POW_PRECISION = k;\n\n                    // Convert str as if an integer, then restore the fraction part by dividing the\n                    // result by its base raised to a power.\n\n                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\n                        10, baseOut, decimal);\n                    y.e = y.c.length;\n                }\n\n                // Convert the number as integer.\n\n                xc = toBaseOut(str, baseIn, baseOut, callerIsToString\n                    ? (alphabet = ALPHABET, decimal)\n                    : (alphabet = decimal, ALPHABET));\n\n                // xc now represents str as an integer and converted to baseOut. e is the exponent.\n                e = k = xc.length;\n\n                // Remove trailing zeros.\n                for (; xc[--k] == 0; xc.pop());\n\n                // Zero?\n                if (!xc[0]) return alphabet.charAt(0);\n\n                // Does str represent an integer? If so, no need for the division.\n                if (i < 0) {\n                    --e;\n                } else {\n                    x.c = xc;\n                    x.e = e;\n\n                    // The sign is needed for correct rounding.\n                    x.s = sign;\n                    x = div(x, y, dp, rm, baseOut);\n                    xc = x.c;\n                    r = x.r;\n                    e = x.e;\n                }\n\n                // xc now represents str converted to baseOut.\n\n                // THe index of the rounding digit.\n                d = e + dp + 1;\n\n                // The rounding digit: the digit to the right of the digit that may be rounded up.\n                i = xc[d];\n\n                // Look at the rounding digits and mode to determine whether to round up.\n\n                k = baseOut / 2;\n                r = r || d < 0 || xc[d + 1] != null;\n\n                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\n                    : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\n                    rm == (x.s < 0 ? 8 : 7));\n\n                // If the index of the rounding digit is not greater than zero, or xc represents\n                // zero, then the result of the base conversion is zero or, if rounding up, a value\n                // such as 0.00001.\n                if (d < 1 || !xc[0]) {\n\n                    // 1^-dp or 0\n                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0))\n                        : alphabet.charAt(0);\n                } else {\n\n                    // Truncate xc to the required number of decimal places.\n                    xc.length = d;\n\n                    // Round up?\n                    if (r) {\n\n                        // Rounding up may mean the previous digit has to be rounded up and so on.\n                        for (--baseOut; ++xc[--d] > baseOut;) {\n                            xc[d] = 0;\n\n                            if (!d) {\n                                ++e;\n                                xc = [1].concat(xc);\n                            }\n                        }\n                    }\n\n                    // Determine trailing zeros.\n                    for (k = xc.length; !xc[--k];);\n\n                    // E.g. [4, 11, 15] becomes 4bf.\n                    for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\n\n                    // Add leading zeros, decimal point and trailing zeros as required.\n                    str = toFixedPoint(str, e, alphabet.charAt(0));\n                }\n\n                // The caller will add the sign.\n                return str;\n            };\n        })();\n\n\n        // Perform division in the specified base. Called by div and convertBase.\n        div = (function () {\n\n            // Assume non-zero x and k.\n            function multiply(x, k, base) {\n                var m, temp, xlo, xhi,\n                    carry = 0,\n                    i = x.length,\n                    klo = k % SQRT_BASE,\n                    khi = k / SQRT_BASE | 0;\n\n                for (x = x.slice(); i--;) {\n                    xlo = x[i] % SQRT_BASE;\n                    xhi = x[i] / SQRT_BASE | 0;\n                    m = khi * xlo + xhi * klo;\n                    temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\n                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\n                    x[i] = temp % base;\n                }\n\n                if (carry) x = [carry].concat(x);\n\n                return x;\n            }\n\n            function compare(a, b, aL, bL) {\n                var i, cmp;\n\n                if (aL != bL) {\n                    cmp = aL > bL ? 1 : -1;\n                } else {\n\n                    for (i = cmp = 0; i < aL; i++) {\n\n                        if (a[i] != b[i]) {\n                            cmp = a[i] > b[i] ? 1 : -1;\n                            break;\n                        }\n                    }\n                }\n\n                return cmp;\n            }\n\n            function subtract(a, b, aL, base) {\n                var i = 0;\n\n                // Subtract b from a.\n                for (; aL--;) {\n                    a[aL] -= i;\n                    i = a[aL] < b[aL] ? 1 : 0;\n                    a[aL] = i * base + a[aL] - b[aL];\n                }\n\n                // Remove leading zeros.\n                for (; !a[0] && a.length > 1; a.splice(0, 1));\n            }\n\n            // x: dividend, y: divisor.\n            return function (x, y, dp, rm, base) {\n                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\n                    yL, yz,\n                    s = x.s == y.s ? 1 : -1,\n                    xc = x.c,\n                    yc = y.c;\n\n                // Either NaN, Infinity or 0?\n                if (!xc || !xc[0] || !yc || !yc[0]) {\n\n                    return new BigNumber(\n\n                        // Return NaN if either NaN, or both Infinity or 0.\n                        !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\n\n                            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\n                            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\n                    );\n                }\n\n                q = new BigNumber(s);\n                qc = q.c = [];\n                e = x.e - y.e;\n                s = dp + e + 1;\n\n                if (!base) {\n                    base = BASE;\n                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\n                    s = s / LOG_BASE | 0;\n                }\n\n                // Result exponent may be one less then the current value of e.\n                // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n                for (i = 0; yc[i] == (xc[i] || 0); i++);\n\n                if (yc[i] > (xc[i] || 0)) e--;\n\n                if (s < 0) {\n                    qc.push(1);\n                    more = true;\n                } else {\n                    xL = xc.length;\n                    yL = yc.length;\n                    i = 0;\n                    s += 2;\n\n                    // Normalise xc and yc so highest order digit of yc is >= base / 2.\n\n                    n = mathfloor(base / (yc[0] + 1));\n\n                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\n                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\n                    if (n > 1) {\n                        yc = multiply(yc, n, base);\n                        xc = multiply(xc, n, base);\n                        yL = yc.length;\n                        xL = xc.length;\n                    }\n\n                    xi = yL;\n                    rem = xc.slice(0, yL);\n                    remL = rem.length;\n\n                    // Add zeros to make remainder as long as divisor.\n                    for (; remL < yL; rem[remL++] = 0);\n                    yz = yc.slice();\n                    yz = [0].concat(yz);\n                    yc0 = yc[0];\n                    if (yc[1] >= base / 2) yc0++;\n                    // Not necessary, but to prevent trial digit n > base, when using base 3.\n                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\n\n                    do {\n                        n = 0;\n\n                        // Compare divisor and remainder.\n                        cmp = compare(yc, rem, yL, remL);\n\n                        // If divisor < remainder.\n                        if (cmp < 0) {\n\n                            // Calculate trial digit, n.\n\n                            rem0 = rem[0];\n                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n\n                            // n is how many times the divisor goes into the current remainder.\n                            n = mathfloor(rem0 / yc0);\n\n                            //  Algorithm:\n                            //  product = divisor multiplied by trial digit (n).\n                            //  Compare product and remainder.\n                            //  If product is greater than remainder:\n                            //    Subtract divisor from product, decrement trial digit.\n                            //  Subtract product from remainder.\n                            //  If product was less than remainder at the last compare:\n                            //    Compare new remainder and divisor.\n                            //    If remainder is greater than divisor:\n                            //      Subtract divisor from remainder, increment trial digit.\n\n                            if (n > 1) {\n\n                                // n may be > base only when base is 3.\n                                if (n >= base) n = base - 1;\n\n                                // product = divisor * trial digit.\n                                prod = multiply(yc, n, base);\n                                prodL = prod.length;\n                                remL = rem.length;\n\n                                // Compare product and remainder.\n                                // If product > remainder then trial digit n too high.\n                                // n is 1 too high about 5% of the time, and is not known to have\n                                // ever been more than 1 too high.\n                                while (compare(prod, rem, prodL, remL) == 1) {\n                                    n--;\n\n                                    // Subtract divisor from product.\n                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);\n                                    prodL = prod.length;\n                                    cmp = 1;\n                                }\n                            } else {\n\n                                // n is 0 or 1, cmp is -1.\n                                // If n is 0, there is no need to compare yc and rem again below,\n                                // so change cmp to 1 to avoid it.\n                                // If n is 1, leave cmp as -1, so yc and rem are compared again.\n                                if (n == 0) {\n\n                                    // divisor < remainder, so n must be at least 1.\n                                    cmp = n = 1;\n                                }\n\n                                // product = divisor\n                                prod = yc.slice();\n                                prodL = prod.length;\n                            }\n\n                            if (prodL < remL) prod = [0].concat(prod);\n\n                            // Subtract product from remainder.\n                            subtract(rem, prod, remL, base);\n                            remL = rem.length;\n\n                            // If product was < remainder.\n                            if (cmp == -1) {\n\n                                // Compare divisor and new remainder.\n                                // If divisor < new remainder, subtract divisor from remainder.\n                                // Trial digit n too low.\n                                // n is 1 too low about 5% of the time, and very rarely 2 too low.\n                                while (compare(yc, rem, yL, remL) < 1) {\n                                    n++;\n\n                                    // Subtract divisor from remainder.\n                                    subtract(rem, yL < remL ? yz : yc, remL, base);\n                                    remL = rem.length;\n                                }\n                            }\n                        } else if (cmp === 0) {\n                            n++;\n                            rem = [0];\n                        } // else cmp === 1 and n will be 0\n\n                        // Add the next digit, n, to the result array.\n                        qc[i++] = n;\n\n                        // Update the remainder.\n                        if (rem[0]) {\n                            rem[remL++] = xc[xi] || 0;\n                        } else {\n                            rem = [xc[xi]];\n                            remL = 1;\n                        }\n                    } while ((xi++ < xL || rem[0] != null) && s--);\n\n                    more = rem[0] != null;\n\n                    // Leading zero?\n                    if (!qc[0]) qc.splice(0, 1);\n                }\n\n                if (base == BASE) {\n\n                    // To calculate q.e, first get the number of digits of qc[0].\n                    for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\n\n                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\n\n                    // Caller is convertBase.\n                } else {\n                    q.e = e;\n                    q.r = +more;\n                }\n\n                return q;\n            };\n        })();\n\n\n        /*\n         * Return a string representing the value of BigNumber n in fixed-point or exponential\n         * notation rounded to the specified decimal places or significant digits.\n         *\n         * n: a BigNumber.\n         * i: the index of the last digit required (i.e. the digit that may be rounded up).\n         * rm: the rounding mode.\n         * id: 1 (toExponential) or 2 (toPrecision).\n         */\n        function format(n, i, rm, id) {\n            var c0, e, ne, len, str;\n\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n\n            if (!n.c) return n.toString();\n\n            c0 = n.c[0];\n            ne = n.e;\n\n            if (i == null) {\n                str = coeffToString(n.c);\n                str = id == 1 || id == 2 && ne <= TO_EXP_NEG\n                    ? toExponential(str, ne)\n                    : toFixedPoint(str, ne, '0');\n            } else {\n                n = round(new BigNumber(n), i, rm);\n\n                // n.e may have changed if the value was rounded up.\n                e = n.e;\n\n                str = coeffToString(n.c);\n                len = str.length;\n\n                // toPrecision returns exponential notation if the number of significant digits\n                // specified is less than the number of digits necessary to represent the integer\n                // part of the value in fixed-point notation.\n\n                // Exponential notation.\n                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\n\n                    // Append zeros?\n                    for (; len < i; str += '0', len++);\n                    str = toExponential(str, e);\n\n                    // Fixed-point notation.\n                } else {\n                    i -= ne;\n                    str = toFixedPoint(str, e, '0');\n\n                    // Append zeros?\n                    if (e + 1 > len) {\n                        if (--i > 0) for (str += '.'; i--; str += '0');\n                    } else {\n                        i += e - len;\n                        if (i > 0) {\n                            if (e + 1 == len) str += '.';\n                            for (; i--; str += '0');\n                        }\n                    }\n                }\n            }\n\n            return n.s < 0 && c0 ? '-' + str : str;\n        }\n\n\n        // Handle BigNumber.max and BigNumber.min.\n        function maxOrMin(args, method) {\n            var m, n,\n                i = 0;\n\n            if (isArray(args[0])) args = args[0];\n            m = new BigNumber(args[0]);\n\n            for (; ++i < args.length;) {\n                n = new BigNumber(args[i]);\n\n                // If any number is NaN, return NaN.\n                if (!n.s) {\n                    m = n;\n                    break;\n                } else if (method.call(m, n)) {\n                    m = n;\n                }\n            }\n\n            return m;\n        }\n\n\n        /*\n         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\n         * Called by minus, plus and times.\n         */\n        function normalise(n, c, e) {\n            var i = 1,\n                j = c.length;\n\n            // Remove trailing zeros.\n            for (; !c[--j]; c.pop());\n\n            // Calculate the base 10 exponent. First get the number of digits of c[0].\n            for (j = c[0]; j >= 10; j /= 10, i++);\n\n            // Overflow?\n            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\n\n                // Infinity.\n                n.c = n.e = null;\n\n                // Underflow?\n            } else if (e < MIN_EXP) {\n\n                // Zero.\n                n.c = [n.e = 0];\n            } else {\n                n.e = e;\n                n.c = c;\n            }\n\n            return n;\n        }\n\n\n        // Handle values that fail the validity test in BigNumber.\n        parseNumeric = (function () {\n            var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\n                dotAfter = /^([^.]+)\\.$/,\n                dotBefore = /^\\.([^.]+)$/,\n                isInfinityOrNaN = /^-?(Infinity|NaN)$/,\n                whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n\n            return function (x, str, isNum, b) {\n                var base,\n                    s = isNum ? str : str.replace(whitespaceOrPlus, '');\n\n                // No exception on Infinity or NaN.\n                if (isInfinityOrNaN.test(s)) {\n                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\n                    x.c = x.e = null;\n                } else {\n                    if (!isNum) {\n\n                        // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\n                        s = s.replace(basePrefix, function (m, p1, p2) {\n                            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\n                            return !b || b == base ? p1 : m;\n                        });\n\n                        if (b) {\n                            base = b;\n\n                            // E.g. '1.' to '1', '.1' to '0.1'\n                            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\n                        }\n\n                        if (str != s) return new BigNumber(s, base);\n                    }\n\n                    // '[BigNumber Error] Not a number: {n}'\n                    // '[BigNumber Error] Not a base {b} number: {n}'\n                    if (BigNumber.DEBUG) {\n                        throw Error\n                        (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\n                    }\n\n                    // NaN\n                    x.c = x.e = x.s = null;\n                }\n            }\n        })();\n\n\n        /*\n         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\n         * If r is truthy, it is known that there are more digits after the rounding digit.\n         */\n        function round(x, sd, rm, r) {\n            var d, i, j, k, n, ni, rd,\n                xc = x.c,\n                pows10 = POWS_TEN;\n\n            // if x is not Infinity or NaN...\n            if (xc) {\n\n                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\n                // n is a base 1e14 number, the value of the element of array x.c containing rd.\n                // ni is the index of n within x.c.\n                // d is the number of digits of n.\n                // i is the index of rd within n including leading zeros.\n                // j is the actual index of rd within n (if < 0, rd is a leading zero).\n                out: {\n\n                    // Get the number of digits of the first element of xc.\n                    for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\n                    i = sd - d;\n\n                    // If the rounding digit is in the first element of xc...\n                    if (i < 0) {\n                        i += LOG_BASE;\n                        j = sd;\n                        n = xc[ni = 0];\n\n                        // Get the rounding digit at index j of n.\n                        rd = n / pows10[d - j - 1] % 10 | 0;\n                    } else {\n                        ni = mathceil((i + 1) / LOG_BASE);\n\n                        if (ni >= xc.length) {\n\n                            if (r) {\n\n                                // Needed by sqrt.\n                                for (; xc.length <= ni; xc.push(0));\n                                n = rd = 0;\n                                d = 1;\n                                i %= LOG_BASE;\n                                j = i - LOG_BASE + 1;\n                            } else {\n                                break out;\n                            }\n                        } else {\n                            n = k = xc[ni];\n\n                            // Get the number of digits of n.\n                            for (d = 1; k >= 10; k /= 10, d++);\n\n                            // Get the index of rd within n.\n                            i %= LOG_BASE;\n\n                            // Get the index of rd within n, adjusted for leading zeros.\n                            // The number of leading zeros of n is given by LOG_BASE - d.\n                            j = i - LOG_BASE + d;\n\n                            // Get the rounding digit at index j of n.\n                            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\n                        }\n                    }\n\n                    r = r || sd < 0 ||\n\n                        // Are there any non-zero digits after the rounding digit?\n                        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n                        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\n\n                    r = rm < 4\n                        ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\n                        : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\n\n                        // Check whether the digit to the left of the rounding digit is odd.\n                        ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\n                        rm == (x.s < 0 ? 8 : 7));\n\n                    if (sd < 1 || !xc[0]) {\n                        xc.length = 0;\n\n                        if (r) {\n\n                            // Convert sd to decimal places.\n                            sd -= x.e + 1;\n\n                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\n                            x.e = -sd || 0;\n                        } else {\n\n                            // Zero.\n                            xc[0] = x.e = 0;\n                        }\n\n                        return x;\n                    }\n\n                    // Remove excess digits.\n                    if (i == 0) {\n                        xc.length = ni;\n                        k = 1;\n                        ni--;\n                    } else {\n                        xc.length = ni + 1;\n                        k = pows10[LOG_BASE - i];\n\n                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                        // j > 0 means i > number of leading zeros of n.\n                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\n                    }\n\n                    // Round up?\n                    if (r) {\n\n                        for (; ;) {\n\n                            // If the digit to be rounded up is in the first element of xc...\n                            if (ni == 0) {\n\n                                // i will be the length of xc[0] before k is added.\n                                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\n                                j = xc[0] += k;\n                                for (k = 1; j >= 10; j /= 10, k++);\n\n                                // if i != k the length has increased.\n                                if (i != k) {\n                                    x.e++;\n                                    if (xc[0] == BASE) xc[0] = 1;\n                                }\n\n                                break;\n                            } else {\n                                xc[ni] += k;\n                                if (xc[ni] != BASE) break;\n                                xc[ni--] = 0;\n                                k = 1;\n                            }\n                        }\n                    }\n\n                    // Remove trailing zeros.\n                    for (i = xc.length; xc[--i] === 0; xc.pop());\n                }\n\n                // Overflow? Infinity.\n                if (x.e > MAX_EXP) {\n                    x.c = x.e = null;\n\n                    // Underflow? Zero.\n                } else if (x.e < MIN_EXP) {\n                    x.c = [x.e = 0];\n                }\n            }\n\n            return x;\n        }\n\n\n        // PROTOTYPE/INSTANCE METHODS\n\n\n        /*\n         * Return a new BigNumber whose value is the absolute value of this BigNumber.\n         */\n        P.absoluteValue = P.abs = function () {\n            var x = new BigNumber(this);\n            if (x.s < 0) x.s = 1;\n            return x;\n        };\n\n\n        /*\n         * Return\n         *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\n         *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\n         *   0 if they have the same value,\n         *   or null if the value of either is NaN.\n         */\n        P.comparedTo = function (y, b) {\n            return compare(this, new BigNumber(y, b));\n        };\n\n\n        /*\n         * If dp is undefined or null or true or false, return the number of decimal places of the\n         * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\n         *\n         * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\n         * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\n         * ROUNDING_MODE if rm is omitted.\n         *\n         * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\n         */\n        P.decimalPlaces = P.dp = function (dp, rm) {\n            var c, n, v,\n                x = this;\n\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                if (rm == null) rm = ROUNDING_MODE;\n                else intCheck(rm, 0, 8);\n\n                return round(new BigNumber(x), dp + x.e + 1, rm);\n            }\n\n            if (!(c = x.c)) return null;\n            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\n\n            // Subtract the number of trailing zeros of the last number.\n            if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\n            if (n < 0) n = 0;\n\n            return n;\n        };\n\n\n        /*\n         *  n / 0 = I\n         *  n / N = N\n         *  n / I = 0\n         *  0 / n = 0\n         *  0 / 0 = N\n         *  0 / N = N\n         *  0 / I = 0\n         *  N / n = N\n         *  N / 0 = N\n         *  N / N = N\n         *  N / I = N\n         *  I / n = I\n         *  I / 0 = I\n         *  I / N = N\n         *  I / I = N\n         *\n         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\n         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\n         */\n        P.dividedBy = P.div = function (y, b) {\n            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\n        };\n\n\n        /*\n         * Return a new BigNumber whose value is the integer part of dividing the value of this\n         * BigNumber by the value of BigNumber(y, b).\n         */\n        P.dividedToIntegerBy = P.idiv = function (y, b) {\n            return div(this, new BigNumber(y, b), 0, 1);\n        };\n\n\n        /*\n         * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\n         *\n         * If m is present, return the result modulo m.\n         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\n         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\n         *\n         * The modular power operation works efficiently when x, n, and m are integers, otherwise it\n         * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\n         *\n         * n {number|string|BigNumber} The exponent. An integer.\n         * [m] {number|string|BigNumber} The modulus.\n         *\n         * '[BigNumber Error] Exponent not an integer: {n}'\n         */\n        P.exponentiatedBy = P.pow = function (n, m) {\n            var half, isModExp, k, more, nIsBig, nIsNeg, nIsOdd, y,\n                x = this;\n\n            n = new BigNumber(n);\n\n            // Allow NaN and Infinity, but not other non-integers.\n            if (n.c && !n.isInteger()) {\n                throw Error\n                (bignumberError + 'Exponent not an integer: ' + n);\n            }\n\n            if (m != null) m = new BigNumber(m);\n\n            // Exponent of MAX_SAFE_INTEGER is 15.\n            nIsBig = n.e > 14;\n\n            // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\n            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\n\n                // The sign of the result of pow when x is negative depends on the evenness of n.\n                // If +n overflows to Infinity, the evenness of n would be not be known.\n                y = new BigNumber(Math.pow(+x.valueOf(), nIsBig ? 2 - isOdd(n) : +n));\n                return m ? y.mod(m) : y;\n            }\n\n            nIsNeg = n.s < 0;\n\n            if (m) {\n\n                // x % m returns NaN if abs(m) is zero, or m is NaN.\n                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\n\n                isModExp = !nIsNeg && x.isInteger() && m.isInteger();\n\n                if (isModExp) x = x.mod(m);\n\n                // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\n                // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\n            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\n                // [1, 240000000]\n                ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\n                // [80000000000000]  [99999750000000]\n                : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\n\n                // If x is negative and n is odd, k = -0, else k = 0.\n                k = x.s < 0 && isOdd(n) ? -0 : 0;\n\n                // If x >= 1, k = Infinity.\n                if (x.e > -1) k = 1 / k;\n\n                // If n is negative return 0, else return Infinity.\n                return new BigNumber(nIsNeg ? 1 / k : k);\n\n            } else if (POW_PRECISION) {\n\n                // Truncating each coefficient array to a length of k after each multiplication\n                // equates to truncating significant digits to POW_PRECISION + [28, 41],\n                // i.e. there will be a minimum of 28 guard digits retained.\n                k = mathceil(POW_PRECISION / LOG_BASE + 2);\n            }\n\n            if (nIsBig) {\n                half = new BigNumber(0.5);\n                nIsOdd = isOdd(n);\n            } else {\n                nIsOdd = n % 2;\n            }\n\n            if (nIsNeg) n.s = 1;\n\n            y = new BigNumber(ONE);\n\n            // Performs 54 loop iterations for n of 9007199254740991.\n            for (; ;) {\n\n                if (nIsOdd) {\n                    y = y.times(x);\n                    if (!y.c) break;\n\n                    if (k) {\n                        if (y.c.length > k) y.c.length = k;\n                    } else if (isModExp) {\n                        y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\n                    }\n                }\n\n                if (nIsBig) {\n                    n = n.times(half);\n                    round(n, n.e + 1, 1);\n                    if (!n.c[0]) break;\n                    nIsBig = n.e > 14;\n                    nIsOdd = isOdd(n);\n                } else {\n                    n = mathfloor(n / 2);\n                    if (!n) break;\n                    nIsOdd = n % 2;\n                }\n\n                x = x.times(x);\n\n                if (k) {\n                    if (x.c && x.c.length > k) x.c.length = k;\n                } else if (isModExp) {\n                    x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\n                }\n            }\n\n            if (isModExp) return y;\n            if (nIsNeg) y = ONE.div(y);\n\n            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\n        };\n\n\n        /*\n         * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\n         * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\n         *\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\n         */\n        P.integerValue = function (rm) {\n            var n = new BigNumber(this);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(n, n.e + 1, rm);\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\n         * otherwise return false.\n         */\n        P.isEqualTo = P.eq = P.equals = function (y, b) {\n            return compare(this, new BigNumber(y, b)) === 0;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is a finite number, otherwise return false.\n         */\n        P.isFinite = function () {\n            return !!this.c;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\n         * otherwise return false.\n         */\n        P.isGreaterThan = P.gt = function (y, b) {\n            return compare(this, new BigNumber(y, b)) > 0;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is greater than or equal to the value of\n         * BigNumber(y, b), otherwise return false.\n         */\n        P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\n            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\n\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is an integer, otherwise return false.\n         */\n        P.isInteger = function () {\n            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\n         * otherwise return false.\n         */\n        P.isLessThan = P.lt = function (y, b) {\n            return compare(this, new BigNumber(y, b)) < 0;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is less than or equal to the value of\n         * BigNumber(y, b), otherwise return false.\n         */\n        P.isLessThanOrEqualTo = P.lte = function (y, b) {\n            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is NaN, otherwise return false.\n         */\n        P.isNaN = function () {\n            return !this.s;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is negative, otherwise return false.\n         */\n        P.isNegative = function () {\n            return this.s < 0;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is positive, otherwise return false.\n         */\n        P.isPositive = function () {\n            return this.s > 0;\n        };\n\n\n        /*\n         * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\n         */\n        P.isZero = function () {\n            return !!this.c && this.c[0] == 0;\n        };\n\n\n        /*\n         *  n - 0 = n\n         *  n - N = N\n         *  n - I = -I\n         *  0 - n = -n\n         *  0 - 0 = 0\n         *  0 - N = N\n         *  0 - I = -I\n         *  N - n = N\n         *  N - 0 = N\n         *  N - N = N\n         *  N - I = N\n         *  I - n = I\n         *  I - 0 = I\n         *  I - N = N\n         *  I - I = N\n         *\n         * Return a new BigNumber whose value is the value of this BigNumber minus the value of\n         * BigNumber(y, b).\n         */\n        P.minus = function (y, b) {\n            var i, j, t, xLTy,\n                x = this,\n                a = x.s;\n\n            y = new BigNumber(y, b);\n            b = y.s;\n\n            // Either NaN?\n            if (!a || !b) return new BigNumber(NaN);\n\n            // Signs differ?\n            if (a != b) {\n                y.s = -b;\n                return x.plus(y);\n            }\n\n            var xe = x.e / LOG_BASE,\n                ye = y.e / LOG_BASE,\n                xc = x.c,\n                yc = y.c;\n\n            if (!xe || !ye) {\n\n                // Either Infinity?\n                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\n\n                // Either zero?\n                if (!xc[0] || !yc[0]) {\n\n                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\n\n                        // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                        ROUNDING_MODE == 3 ? -0 : 0);\n                }\n            }\n\n            xe = bitFloor(xe);\n            ye = bitFloor(ye);\n            xc = xc.slice();\n\n            // Determine which is the bigger number.\n            if (a = xe - ye) {\n\n                if (xLTy = a < 0) {\n                    a = -a;\n                    t = xc;\n                } else {\n                    ye = xe;\n                    t = yc;\n                }\n\n                t.reverse();\n\n                // Prepend zeros to equalise exponents.\n                for (b = a; b--; t.push(0));\n                t.reverse();\n            } else {\n\n                // Exponents equal. Check digit by digit.\n                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\n\n                for (a = b = 0; b < j; b++) {\n\n                    if (xc[b] != yc[b]) {\n                        xLTy = xc[b] < yc[b];\n                        break;\n                    }\n                }\n            }\n\n            // x < y? Point xc to the array of the bigger number.\n            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\n\n            b = (j = yc.length) - (i = xc.length);\n\n            // Append zeros to xc if shorter.\n            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\n            if (b > 0) for (; b--; xc[i++] = 0);\n            b = BASE - 1;\n\n            // Subtract yc from xc.\n            for (; j > a;) {\n\n                if (xc[--j] < yc[j]) {\n                    for (i = j; i && !xc[--i]; xc[i] = b);\n                    --xc[i];\n                    xc[j] += BASE;\n                }\n\n                xc[j] -= yc[j];\n            }\n\n            // Remove leading zeros and adjust exponent accordingly.\n            for (; xc[0] == 0; xc.splice(0, 1), --ye);\n\n            // Zero?\n            if (!xc[0]) {\n\n                // Following IEEE 754 (2008) 6.3,\n                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n                y.s = ROUNDING_MODE == 3 ? -1 : 1;\n                y.c = [y.e = 0];\n                return y;\n            }\n\n            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n            // for finite x and y.\n            return normalise(y, xc, ye);\n        };\n\n\n        /*\n         *   n % 0 =  N\n         *   n % N =  N\n         *   n % I =  n\n         *   0 % n =  0\n         *  -0 % n = -0\n         *   0 % 0 =  N\n         *   0 % N =  N\n         *   0 % I =  0\n         *   N % n =  N\n         *   N % 0 =  N\n         *   N % N =  N\n         *   N % I =  N\n         *   I % n =  N\n         *   I % 0 =  N\n         *   I % N =  N\n         *   I % I =  N\n         *\n         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\n         * BigNumber(y, b). The result depends on the value of MODULO_MODE.\n         */\n        P.modulo = P.mod = function (y, b) {\n            var q, s,\n                x = this;\n\n            y = new BigNumber(y, b);\n\n            // Return NaN if x is Infinity or NaN, or y is NaN or zero.\n            if (!x.c || !y.s || y.c && !y.c[0]) {\n                return new BigNumber(NaN);\n\n                // Return x if y is Infinity or x is zero.\n            } else if (!y.c || x.c && !x.c[0]) {\n                return new BigNumber(x);\n            }\n\n            if (MODULO_MODE == 9) {\n\n                // Euclidian division: q = sign(y) * floor(x / abs(y))\n                // r = x - qy    where  0 <= r < abs(y)\n                s = y.s;\n                y.s = 1;\n                q = div(x, y, 0, 3);\n                y.s = s;\n                q.s *= s;\n            } else {\n                q = div(x, y, 0, MODULO_MODE);\n            }\n\n            y = x.minus(q.times(y));\n\n            // To match JavaScript %, ensure sign of zero is sign of dividend.\n            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\n\n            return y;\n        };\n\n\n        /*\n         *  n * 0 = 0\n         *  n * N = N\n         *  n * I = I\n         *  0 * n = 0\n         *  0 * 0 = 0\n         *  0 * N = N\n         *  0 * I = N\n         *  N * n = N\n         *  N * 0 = N\n         *  N * N = N\n         *  N * I = N\n         *  I * n = I\n         *  I * 0 = N\n         *  I * N = N\n         *  I * I = I\n         *\n         * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\n         * of BigNumber(y, b).\n         */\n        P.multipliedBy = P.times = function (y, b) {\n            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\n                base, sqrtBase,\n                x = this,\n                xc = x.c,\n                yc = (y = new BigNumber(y, b)).c;\n\n            // Either NaN, Infinity or 0?\n            if (!xc || !yc || !xc[0] || !yc[0]) {\n\n                // Return NaN if either is NaN, or one is 0 and the other is Infinity.\n                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\n                    y.c = y.e = y.s = null;\n                } else {\n                    y.s *= x.s;\n\n                    // Return Infinity if either is Infinity.\n                    if (!xc || !yc) {\n                        y.c = y.e = null;\n\n                        // Return 0 if either is 0.\n                    } else {\n                        y.c = [0];\n                        y.e = 0;\n                    }\n                }\n\n                return y;\n            }\n\n            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\n            y.s *= x.s;\n            xcL = xc.length;\n            ycL = yc.length;\n\n            // Ensure xc points to longer array and xcL to its length.\n            if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\n\n            // Initialise the result array with zeros.\n            for (i = xcL + ycL, zc = []; i--; zc.push(0));\n\n            base = BASE;\n            sqrtBase = SQRT_BASE;\n\n            for (i = ycL; --i >= 0;) {\n                c = 0;\n                ylo = yc[i] % sqrtBase;\n                yhi = yc[i] / sqrtBase | 0;\n\n                for (k = xcL, j = i + k; j > i;) {\n                    xlo = xc[--k] % sqrtBase;\n                    xhi = xc[k] / sqrtBase | 0;\n                    m = yhi * xlo + xhi * ylo;\n                    xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\n                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\n                    zc[j--] = xlo % base;\n                }\n\n                zc[j] = c;\n            }\n\n            if (c) {\n                ++e;\n            } else {\n                zc.splice(0, 1);\n            }\n\n            return normalise(y, zc, e);\n        };\n\n\n        /*\n         * Return a new BigNumber whose value is the value of this BigNumber negated,\n         * i.e. multiplied by -1.\n         */\n        P.negated = function () {\n            var x = new BigNumber(this);\n            x.s = -x.s || null;\n            return x;\n        };\n\n\n        /*\n         *  n + 0 = n\n         *  n + N = N\n         *  n + I = I\n         *  0 + n = n\n         *  0 + 0 = 0\n         *  0 + N = N\n         *  0 + I = I\n         *  N + n = N\n         *  N + 0 = N\n         *  N + N = N\n         *  N + I = N\n         *  I + n = I\n         *  I + 0 = I\n         *  I + N = N\n         *  I + I = I\n         *\n         * Return a new BigNumber whose value is the value of this BigNumber plus the value of\n         * BigNumber(y, b).\n         */\n        P.plus = function (y, b) {\n            var t,\n                x = this,\n                a = x.s;\n\n            y = new BigNumber(y, b);\n            b = y.s;\n\n            // Either NaN?\n            if (!a || !b) return new BigNumber(NaN);\n\n            // Signs differ?\n            if (a != b) {\n                y.s = -b;\n                return x.minus(y);\n            }\n\n            var xe = x.e / LOG_BASE,\n                ye = y.e / LOG_BASE,\n                xc = x.c,\n                yc = y.c;\n\n            if (!xe || !ye) {\n\n                // Return Infinity if either Infinity.\n                if (!xc || !yc) return new BigNumber(a / 0);\n\n                // Either zero?\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\n            }\n\n            xe = bitFloor(xe);\n            ye = bitFloor(ye);\n            xc = xc.slice();\n\n            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n            if (a = xe - ye) {\n                if (a > 0) {\n                    ye = xe;\n                    t = yc;\n                } else {\n                    a = -a;\n                    t = xc;\n                }\n\n                t.reverse();\n                for (; a--; t.push(0));\n                t.reverse();\n            }\n\n            a = xc.length;\n            b = yc.length;\n\n            // Point xc to the longer array, and b to the shorter length.\n            if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\n\n            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\n            for (a = 0; b;) {\n                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\n                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\n            }\n\n            if (a) {\n                xc = [a].concat(xc);\n                ++ye;\n            }\n\n            // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n            // ye = MAX_EXP + 1 possible\n            return normalise(y, xc, ye);\n        };\n\n\n        /*\n         * If sd is undefined or null or true or false, return the number of significant digits of\n         * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\n         * If sd is true include integer-part trailing zeros in the count.\n         *\n         * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\n         * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\n         * ROUNDING_MODE if rm is omitted.\n         *\n         * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\n         *                     boolean: whether to count integer-part trailing zeros: true or false.\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\n         */\n        P.precision = P.sd = function (sd, rm) {\n            var c, n, v,\n                x = this;\n\n            if (sd != null && sd !== !!sd) {\n                intCheck(sd, 1, MAX);\n                if (rm == null) rm = ROUNDING_MODE;\n                else intCheck(rm, 0, 8);\n\n                return round(new BigNumber(x), sd, rm);\n            }\n\n            if (!(c = x.c)) return null;\n            v = c.length - 1;\n            n = v * LOG_BASE + 1;\n\n            if (v = c[v]) {\n\n                // Subtract the number of trailing zeros of the last element.\n                for (; v % 10 == 0; v /= 10, n--);\n\n                // Add the number of digits of the first element.\n                for (v = c[0]; v >= 10; v /= 10, n++);\n            }\n\n            if (sd && x.e + 1 > n) n = x.e + 1;\n\n            return n;\n        };\n\n\n        /*\n         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\n         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\n         *\n         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\n         */\n        P.shiftedBy = function (k) {\n            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n            return this.times('1e' + k);\n        };\n\n\n        /*\n         *  sqrt(-n) =  N\n         *  sqrt(N) =  N\n         *  sqrt(-I) =  N\n         *  sqrt(I) =  I\n         *  sqrt(0) =  0\n         *  sqrt(-0) = -0\n         *\n         * Return a new BigNumber whose value is the square root of the value of this BigNumber,\n         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\n         */\n        P.squareRoot = P.sqrt = function () {\n            var m, n, r, rep, t,\n                x = this,\n                c = x.c,\n                s = x.s,\n                e = x.e,\n                dp = DECIMAL_PLACES + 4,\n                half = new BigNumber('0.5');\n\n            // Negative/NaN/Infinity/zero?\n            if (s !== 1 || !c || !c[0]) {\n                return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\n            }\n\n            // Initial estimate.\n            s = Math.sqrt(+x);\n\n            // Math.sqrt underflow/overflow?\n            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n            if (s == 0 || s == 1 / 0) {\n                n = coeffToString(c);\n                if ((n.length + e) % 2 == 0) n += '0';\n                s = Math.sqrt(n);\n                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\n\n                if (s == 1 / 0) {\n                    n = '1e' + e;\n                } else {\n                    n = s.toExponential();\n                    n = n.slice(0, n.indexOf('e') + 1) + e;\n                }\n\n                r = new BigNumber(n);\n            } else {\n                r = new BigNumber(s + '');\n            }\n\n            // Check for zero.\n            // r could be zero if MIN_EXP is changed after the this value was created.\n            // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n            // coeffToString to throw.\n            if (r.c[0]) {\n                e = r.e;\n                s = e + dp;\n                if (s < 3) s = 0;\n\n                // Newton-Raphson iteration.\n                for (; ;) {\n                    t = r;\n                    r = half.times(t.plus(div(x, t, dp, 1)));\n\n                    if (coeffToString(t.c  ).slice(0, s) === (n =\n                        coeffToString(r.c)).slice(0, s)) {\n\n                        // The exponent of r may here be one less than the final result exponent,\n                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\n                        // are indexed correctly.\n                        if (r.e < e) --s;\n                        n = n.slice(s - 3, s + 1);\n\n                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\n                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\n                        // iteration.\n                        if (n == '9999' || !rep && n == '4999') {\n\n                            // On the first iteration only, check to see if rounding up gives the\n                            // exact result as the nines may infinitely repeat.\n                            if (!rep) {\n                                round(t, t.e + DECIMAL_PLACES + 2, 0);\n\n                                if (t.times(t).eq(x)) {\n                                    r = t;\n                                    break;\n                                }\n                            }\n\n                            dp += 4;\n                            s += 4;\n                            rep = 1;\n                        } else {\n\n                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\n                            // result. If not, then there are further digits and m will be truthy.\n                            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\n\n                                // Truncate to the first rounding digit.\n                                round(r, r.e + DECIMAL_PLACES + 2, 1);\n                                m = !r.times(r).eq(x);\n                            }\n\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\n        };\n\n\n        /*\n         * Return a string representing the value of this BigNumber in exponential notation and\n         * rounded using ROUNDING_MODE to dp fixed decimal places.\n         *\n         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\n         */\n        P.toExponential = function (dp, rm) {\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                dp++;\n            }\n            return format(this, dp, rm, 1);\n        };\n\n\n        /*\n         * Return a string representing the value of this BigNumber in fixed-point notation rounding\n         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\n         *\n         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\n         * but e.g. (-0.00001).toFixed(0) is '-0'.\n         *\n         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\n         */\n        P.toFixed = function (dp, rm) {\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                dp = dp + this.e + 1;\n            }\n            return format(this, dp, rm);\n        };\n\n\n        /*\n         * Return a string representing the value of this BigNumber in fixed-point notation rounded\n         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\n         * of the FORMAT object (see BigNumber.set).\n         *\n         * FORMAT = {\n         *      decimalSeparator : '.',\n         *      groupSeparator : ',',\n         *      groupSize : 3,\n         *      secondaryGroupSize : 0,\n         *      fractionGroupSeparator : '\\xA0',    // non-breaking space\n         *      fractionGroupSize : 0\n         * };\n         *\n         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\n         */\n        P.toFormat = function (dp, rm) {\n            var str = this.toFixed(dp, rm);\n\n            if (this.c) {\n                var i,\n                    arr = str.split('.'),\n                    g1 = +FORMAT.groupSize,\n                    g2 = +FORMAT.secondaryGroupSize,\n                    groupSeparator = FORMAT.groupSeparator,\n                    intPart = arr[0],\n                    fractionPart = arr[1],\n                    isNeg = this.s < 0,\n                    intDigits = isNeg ? intPart.slice(1) : intPart,\n                    len = intDigits.length;\n\n                if (g2) i = g1, g1 = g2, g2 = i, len -= i;\n\n                if (g1 > 0 && len > 0) {\n                    i = len % g1 || g1;\n                    intPart = intDigits.substr(0, i);\n\n                    for (; i < len; i += g1) {\n                        intPart += groupSeparator + intDigits.substr(i, g1);\n                    }\n\n                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\n                    if (isNeg) intPart = '-' + intPart;\n                }\n\n                str = fractionPart\n                    ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize)\n                    ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\n                        '$&' + FORMAT.fractionGroupSeparator)\n                    : fractionPart)\n                    : intPart;\n            }\n\n            return str;\n        };\n\n\n        /*\n         * Return a string array representing the value of this BigNumber as a simple fraction with\n         * an integer numerator and an integer denominator. The denominator will be a positive\n         * non-zero value less than or equal to the specified maximum denominator. If a maximum\n         * denominator is not specified, the denominator will be the lowest value necessary to\n         * represent the number exactly.\n         *\n         * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\n         *\n         * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\n         */\n        P.toFraction = function (md) {\n            var arr, d, d0, d1, d2, e, exp, n, n0, n1, q, s,\n                x = this,\n                xc = x.c;\n\n            if (md != null) {\n                n = new BigNumber(md);\n\n                // Throw if md is less than one or is not an integer, unless it is Infinity.\n                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\n                    throw Error\n                    (bignumberError + 'Argument ' +\n                        (n.isInteger() ? 'out of range: ' : 'not an integer: ') + md);\n                }\n            }\n\n            if (!xc) return x.toString();\n\n            d = new BigNumber(ONE);\n            n1 = d0 = new BigNumber(ONE);\n            d1 = n0 = new BigNumber(ONE);\n            s = coeffToString(xc);\n\n            // Determine initial denominator.\n            // d is a power of 10 and the minimum max denominator that specifies the value exactly.\n            e = d.e = s.length - x.e - 1;\n            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\n            md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\n\n            exp = MAX_EXP;\n            MAX_EXP = 1 / 0;\n            n = new BigNumber(s);\n\n            // n0 = d1 = 0\n            n0.c[0] = 0;\n\n            for (; ;)  {\n                q = div(n, d, 0, 1);\n                d2 = d0.plus(q.times(d1));\n                if (d2.comparedTo(md) == 1) break;\n                d0 = d1;\n                d1 = d2;\n                n1 = n0.plus(q.times(d2 = n1));\n                n0 = d2;\n                d = n.minus(q.times(d2 = d));\n                n = d2;\n            }\n\n            d2 = div(md.minus(d0), d1, 0, 1);\n            n0 = n0.plus(d2.times(n1));\n            d0 = d0.plus(d2.times(d1));\n            n0.s = n1.s = x.s;\n            e *= 2;\n\n            // Determine which fraction is closer to x, n0/d0 or n1/d1\n            arr = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\n                div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1\n                ? [n1.toString(), d1.toString()]\n                : [n0.toString(), d0.toString()];\n\n            MAX_EXP = exp;\n            return arr;\n        };\n\n\n        /*\n         * Return the value of this BigNumber converted to a number primitive.\n         */\n        P.toNumber = function () {\n            return +this;\n        };\n\n\n        /*\n         * Return a string representing the value of this BigNumber rounded to sd significant digits\n         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\n         * necessary to represent the integer part of the value in fixed-point notation, then use\n         * exponential notation.\n         *\n         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\n         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\n         *\n         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\n         */\n        P.toPrecision = function (sd, rm) {\n            if (sd != null) intCheck(sd, 1, MAX);\n            return format(this, sd, rm, 2);\n        };\n\n\n        /*\n         * Return a string representing the value of this BigNumber in base b, or base 10 if b is\n         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\n         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\n         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\n         * TO_EXP_NEG, return exponential notation.\n         *\n         * [b] {number} Integer, 2 to ALPHABET.length inclusive.\n         *\n         * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n         */\n        P.toString = function (b) {\n            var str,\n                n = this,\n                s = n.s,\n                e = n.e;\n\n            // Infinity or NaN?\n            if (e === null) {\n\n                if (s) {\n                    str = 'Infinity';\n                    if (s < 0) str = '-' + str;\n                } else {\n                    str = 'NaN';\n                }\n            } else {\n                str = coeffToString(n.c);\n\n                if (b == null) {\n                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\n                        ? toExponential(str, e)\n                        : toFixedPoint(str, e, '0');\n                } else {\n                    intCheck(b, 2, ALPHABET.length, 'Base');\n                    str = convertBase(toFixedPoint(str, e, '0'), 10, b, s, true);\n                }\n\n                if (s < 0 && n.c[0]) str = '-' + str;\n            }\n\n            return str;\n        };\n\n\n        /*\n         * Return as toString, but do not accept a base argument, and include the minus sign for\n         * negative zero.\n         */\n        P.valueOf = P.toJSON = function () {\n            var str,\n                n = this,\n                e = n.e;\n\n            if (e === null) return n.toString();\n\n            str = coeffToString(n.c);\n\n            str = e <= TO_EXP_NEG || e >= TO_EXP_POS\n                ? toExponential(str, e)\n                : toFixedPoint(str, e, '0');\n\n            return n.s < 0 ? '-' + str : str;\n        };\n\n\n        P._isBigNumber = true;\n\n        if (configObject != null) BigNumber.set(configObject);\n\n        return BigNumber;\n    }\n\n\n    // PRIVATE HELPER FUNCTIONS\n\n\n    function bitFloor(n) {\n        var i = n | 0;\n        return n > 0 || n === i ? i : i - 1;\n    }\n\n\n    // Return a coefficient array as a string of base 10 digits.\n    function coeffToString(a) {\n        var s, z,\n            i = 1,\n            j = a.length,\n            r = a[0] + '';\n\n        for (; i < j;) {\n            s = a[i++] + '';\n            z = LOG_BASE - s.length;\n            for (; z--; s = '0' + s);\n            r += s;\n        }\n\n        // Determine trailing zeros.\n        for (j = r.length; r.charCodeAt(--j) === 48;);\n        return r.slice(0, j + 1 || 1);\n    }\n\n\n    // Compare the value of BigNumbers x and y.\n    function compare(x, y) {\n        var a, b,\n            xc = x.c,\n            yc = y.c,\n            i = x.s,\n            j = y.s,\n            k = x.e,\n            l = y.e;\n\n        // Either NaN?\n        if (!i || !j) return null;\n\n        a = xc && !xc[0];\n        b = yc && !yc[0];\n\n        // Either zero?\n        if (a || b) return a ? b ? 0 : -j : i;\n\n        // Signs differ?\n        if (i != j) return i;\n\n        a = i < 0;\n        b = k == l;\n\n        // Either Infinity?\n        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\n\n        // Compare exponents.\n        if (!b) return k > l ^ a ? 1 : -1;\n\n        j = (k = xc.length) < (l = yc.length) ? k : l;\n\n        // Compare digit by digit.\n        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\n\n        // Compare lengths.\n        return k == l ? 0 : k > l ^ a ? 1 : -1;\n    }\n\n\n    /*\n     * Check that n is a primitive number, an integer, and in range, otherwise throw.\n     */\n    function intCheck(n, min, max, name) {\n        if (n < min || n > max || n !== (n < 0 ? mathceil(n) : mathfloor(n))) {\n            throw Error\n            (bignumberError + (name || 'Argument') + (typeof n == 'number'\n                ? n < min || n > max ? ' out of range: ' : ' not an integer: '\n                : ' not a primitive number: ') + n);\n        }\n    }\n\n\n    function isArray(obj) {\n        return Object.prototype.toString.call(obj) == '[object Array]';\n    }\n\n\n    // Assumes finite n.\n    function isOdd(n) {\n        var k = n.c.length - 1;\n        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\n    }\n\n\n    function toExponential(str, e) {\n        return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\n            (e < 0 ? 'e' : 'e+') + e;\n    }\n\n\n    function toFixedPoint(str, e, z) {\n        var len, zs;\n\n        // Negative exponent?\n        if (e < 0) {\n\n            // Prepend zeros.\n            for (zs = z + '.'; ++e; zs += z);\n            str = zs + str;\n\n            // Positive exponent\n        } else {\n            len = str.length;\n\n            // Append zeros.\n            if (++e > len) {\n                for (zs = z, e -= len; --e; zs += z);\n                str += zs;\n            } else if (e < len) {\n                str = str.slice(0, e) + '.' + str.slice(e);\n            }\n        }\n\n        return str;\n    }\n\n\n    // EXPORT\n\n\n    BigNumber = clone();\n    BigNumber['default'] = BigNumber.BigNumber = BigNumber;\n    globalObject.BigNumber = BigNumber;\n})(Class.scope);\nconst BigNumber = Class.scope.BigNumber;\nBigNumber.config({ DECIMAL_PLACES: 10 });\n","class NumberUtils {\n    /**\n     * @param {unknown} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {unknown} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {unknown} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {unknown} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n\n    /**\n     * @param {string} bin\n     * @return {number}\n     */\n    static fromBinary(bin) {\n        return parseInt(bin, 2);\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class BufferUtils {\n    /**\n     * @param {Uint8Array} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        const chunkSize = 0x2000;\n        const buf = BufferUtils._toUint8View(buffer);\n\n        let ascii = '';\n        for (let i = 0; i < buf.length; i += chunkSize) {\n            ascii += String.fromCharCode.apply(null, buf.subarray(i, i + chunkSize));\n        }\n        return ascii;\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(buffer) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not support iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } catch (e) {\n                BufferUtils._ISO_8859_15_DECODER = null;\n                throw new Error('TextDecoder does not support iso-8859-15');\n            }\n        }\n        const uint8View = BufferUtils._toUint8View(buffer);\n        return BufferUtils._ISO_8859_15_DECODER.decode(uint8View)\n            .replace(/\\u20ac/g, '\\u00a4')  //  => \n            .replace(/\\u0160/g, '\\u00a6')  //  => \n            .replace(/\\u0161/g, '\\u00a8')  //  => \n            .replace(/\\u017d/g, '\\u00b4')  //  => \n            .replace(/\\u017e/g, '\\u00b8')  //  => \n            .replace(/\\u0152/g, '\\u00bc')  //  => \n            .replace(/\\u0153/g, '\\u00bd')  //  => \n            .replace(/\\u0178/g, '\\u00be'); //  => \n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {Uint8Array} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return Buffer.from(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(buffer));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(BufferUtils._toUint8View(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @param {number} [length]\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64, length) {\n        const arr = new Uint8Array(atob(base64).split('').map(c => c.charCodeAt(0)));\n        if (length !== undefined && arr.length !== length) throw new Error('Decoded length does not match expected length');\n        return new SerialBuffer(arr);\n    }\n\n    /**\n     * @param {Uint8Array} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @param {number} [length]\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64, length) {\n        return BufferUtils.fromBase64(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '='), length);\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {Uint8Array} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @param {number} [length]\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex, length) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex, length)) throw new Error('String is not an hex string (of matching length)');\n        return new SerialBuffer(new Uint8Array((hex.match(/.{2}/g) || []).map(byte => parseInt(byte, 16))));\n    }\n\n    /**\n     * @param {Uint8Array} buffer\n     * @return {string}\n     */\n    static toBinary(buffer) {\n        let bin = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            bin += StringUtils.lpad(code.toString(2), '0', 8);\n        }\n        return bin;\n    }\n\n    /**\n     * Taken from https://github.com/google/closure-library/blob/master/closure/goog/crypt/crypt.js.\n     *\n     * @param {string} str\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _strToUint8Array(str) {\n        const out = [];\n        let p = 0;\n        for (let i = 0; i < str.length; i++) {\n            let c = str.charCodeAt(i);\n            if (c < 128) {\n                out[p++] = c;\n            } else if (c < 2048) {\n                out[p++] = (c >> 6) | 192;\n                out[p++] = (c & 63) | 128;\n            } else if (\n                ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n                ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n                // Surrogate Pair\n                c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);\n                out[p++] = (c >> 18) | 240;\n                out[p++] = ((c >> 12) & 63) | 128;\n                out[p++] = ((c >> 6) & 63) | 128;\n                out[p++] = (c & 63) | 128;\n            } else {\n                out[p++] = (c >> 12) | 224;\n                out[p++] = ((c >> 6) & 63) | 128;\n                out[p++] = (c & 63) | 128;\n            }\n        }\n        return new Uint8Array(out);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _utf8TextEncoder(str) {\n        if (typeof TextEncoder === 'undefined') throw new Error('TextEncoder not supported');\n        if (BufferUtils._UTF8_ENCODER === null) throw new Error('TextEncoder does not support utf8');\n        if (BufferUtils._UTF8_ENCODER === undefined) {\n            try {\n                BufferUtils._UTF8_ENCODER = new TextEncoder();\n            } catch (e) {\n                BufferUtils._UTF8_ENCODER = null;\n                throw new Error('TextEncoder does not support utf8');\n            }\n        }\n        return BufferUtils._UTF8_ENCODER.encode(str);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Uint8Array}\n     */\n    static fromUtf8(str) {\n        if (PlatformUtils.isNodeJs()) {\n            return Buffer.from(str);\n        } else if (typeof TextEncoder !== 'undefined' && BufferUtils._UTF8_ENCODER !== null) {\n            try {\n                return BufferUtils._utf8TextEncoder(str);\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n        return BufferUtils._strToUint8Array(str);\n    }\n\n    /**\n     * @param {Uint8Array|string} o\n     * @param {number} [length]\n     * @return {SerialBuffer}\n     */\n    static fromAny(o, length) {\n        if (o === '') return SerialBuffer.EMPTY;\n        if (!o) throw new Error('Invalid buffer format');\n        if (o instanceof Uint8Array) return new SerialBuffer(o);\n        try {\n            return BufferUtils.fromHex(o, length);\n        } catch (e) {\n            // Ignore\n        }\n        try {\n            return BufferUtils.fromBase64(o, length);\n        } catch (e) {\n            // Ignore\n        }\n        throw new Error('Invalid buffer format');\n    }\n\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {TypedArray} a\n     * @param {TypedArray} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        const viewA = BufferUtils._toUint8View(a);\n        const viewB = BufferUtils._toUint8View(b);\n        if (viewA.length !== viewB.length) return false;\n        for (let i = 0; i < viewA.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {TypedArray} a\n     * @param {TypedArray} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n\n    /**\n     * @param {TypedArray|ArrayBuffer} arrayLike\n     * @return {Uint8Array}\n     * @private\n     */\n    static _toUint8View(arrayLike) {\n        if (arrayLike instanceof Uint8Array) {\n            return arrayLike;\n        } else if (arrayLike instanceof ArrayBuffer) {\n            return new Uint8Array(arrayLike);\n        } else if (arrayLike.buffer instanceof ArrayBuffer) {\n            return new Uint8Array(arrayLike.buffer);\n        } else {\n            throw new Error('TypedArray or ArrayBuffer required');\n        }\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return new Uint8Array(value);\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw new Error('Malformed value/length');\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw new Error('Malformed value/length');\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw new Error('Malformed length');\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nSerialBuffer.EMPTY = new SerialBuffer(0);\nClass.register(SerialBuffer);\n","/**\n * @interface\n * @deprecated\n */\nclass MinerWorker {\n    /**\n     * @param blockHeader\n     * @param compact\n     * @param minNonce\n     * @param maxNonce\n     * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n     */\n    async multiMine(blockHeader, compact, minNonce, maxNonce) {}\n}\nClass.register(MinerWorker);\n","/**\n * @deprecated\n */\nclass MinerWorkerImpl extends IWorker.Stub(MinerWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        if (PlatformUtils.isBrowser()) await WasmHelper.doImportBrowser();\n    }\n\n    async multiMine(input, compact, minNonce, maxNonce) {\n        const hash = new Uint8Array(32);\n        let wasmOut, wasmIn;\n        try {\n            wasmOut = Module._malloc(hash.length);\n            wasmIn = Module._malloc(input.length);\n            Module.HEAPU8.set(input, wasmIn);\n            const nonce = Module._nimiq_argon2_target(wasmOut, wasmIn, input.length, compact, minNonce, maxNonce, 512);\n            if (nonce === maxNonce) return false;\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hash.length));\n            return {hash, nonce};\n        } catch (e) {\n            Log.w(MinerWorkerImpl, e);\n            throw e;\n        } finally {\n            if (wasmOut !== undefined) Module._free(wasmOut);\n            if (wasmIn !== undefined) Module._free(wasmIn);\n        }\n    }\n}\n\nIWorker.prepareForWorkerUse(MinerWorker, new MinerWorkerImpl());\n","/**\n * @deprecated\n */\nclass MinerWorkerPool extends IWorker.Pool(MinerWorker) {\n    constructor(size = 1) {\n        super((name) => IWorker.startWorkerForProxy(MinerWorker, name), 'miner', size);\n        /** @type {boolean} */\n        this._miningEnabled = false;\n        /** @type {Array.<{minNonce: number, maxNonce: number}>} */\n        this._activeNonces = [];\n        /** @type {Block} */\n        this._block = null;\n        /** @type {number} */\n        this._noncesPerRun = 256;\n        /** @type {Observable} */\n        this._observable = new Observable();\n        /** @type {number} */\n        this._shareCompact = Policy.BLOCK_TARGET_MAX;\n        /** @type {number} */\n        this._runsPerCycle = Infinity;\n        /** @type {number} */\n        this._cycleWait = 100;\n\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superUpdateToSize = super._updateToSize;\n\n        if (PlatformUtils.isNodeJs()) {\n            Log.i(MinerWorkerPool, `Using add-on optimized for instruction set: ${cpuSupport}`);\n\n            /**\n             * @param {SerialBuffer} blockHeader\n             * @param {number} compact\n             * @param {number} minNonce\n             * @param {number} maxNonce\n             * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n             */\n            this.multiMine = function (blockHeader, compact, minNonce, maxNonce) {\n                return new Promise((resolve, fail) => {\n                    NodeNative.node_argon2_target_async(async (nonce) => {\n                        try {\n                            if (nonce === maxNonce) {\n                                resolve(false);\n                            } else {\n                                blockHeader.writePos -= 4;\n                                blockHeader.writeUint32(nonce);\n                                const hash = await (await CryptoWorker.getInstanceAsync()).computeArgon2d(blockHeader);\n                                resolve({hash, nonce});\n                            }\n                        } catch (e) {\n                            fail(e);\n                        }\n                    }, blockHeader, compact, minNonce, maxNonce, 512);\n                });\n            };\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get noncesPerRun() {\n        return this._noncesPerRun;\n    }\n\n    /**\n     * @param {number} nonces\n     */\n    set noncesPerRun(nonces) {\n        this._noncesPerRun = nonces;\n    }\n\n    /**\n     * @type {number}\n     */\n    get runsPerCycle() {\n        return this._runsPerCycle;\n    }\n\n    /**\n     * @param {number} runsPerCycle\n     */\n    set runsPerCycle(runsPerCycle) {\n        this._runsPerCycle = runsPerCycle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get cycleWait() {\n        return this._cycleWait;\n    }\n\n    /**\n     * @param {number} cycleWait\n     */\n    set cycleWait(cycleWait) {\n        this._cycleWait = cycleWait;\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) { return this._observable.on(type, callback); }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) { this._observable.off(type, id); }\n\n    /**\n     * @param {Block} block\n     * @param {number} [shareCompact] target of a share, in compact format.\n     */\n    async startMiningOnBlock(block, shareCompact) {\n        this._block = block;\n        this._shareCompact = shareCompact || block.nBits;\n        if (!this._miningEnabled) {\n            await this._updateToSize();\n            this._activeNonces = [];\n            this._miningEnabled = true;\n            for (let i = 0; i < this.poolSize; ++i) {\n                this._startMiner();\n            }\n        } else {\n            this._activeNonces = [{minNonce:0, maxNonce:0}];\n        }\n    }\n\n    stop() {\n        this._miningEnabled = false;\n    }\n\n    async _updateToSize() {\n        if (!PlatformUtils.isNodeJs()) {\n            await this._superUpdateToSize.call(this);\n        }\n\n        while (this._miningEnabled && this._activeNonces.length < this.poolSize) {\n            this._startMiner();\n        }\n    }\n\n    _startMiner() {\n        if (this._activeNonces.length >= this.poolSize) {\n            return;\n        }\n\n        const minNonce = this._activeNonces.length === 0 ? 0 : Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n        const maxNonce = minNonce + this._noncesPerRun;\n        const nonceRange = {minNonce, maxNonce};\n        this._activeNonces.push(nonceRange);\n        this._singleMiner(nonceRange).catch((e) => Log.e(MinerWorkerPool, e));\n    }\n\n    /**\n     * @param {{minNonce: number, maxNonce: number}} nonceRange\n     * @return {Promise.<void>}\n     * @private\n     */\n    async _singleMiner(nonceRange) {\n        let i = 0;\n        while (this._miningEnabled && (IWorker.areWorkersAsync || PlatformUtils.isNodeJs() || i === 0) && i < this._runsPerCycle) {\n            i++;\n            const block = this._block;\n            const result = await this.multiMine(block.header.serialize(), this._shareCompact, nonceRange.minNonce, nonceRange.maxNonce);\n            if (result) {\n                const hash = new Hash(result.hash);\n                this._observable.fire('share', {\n                    block,\n                    nonce: result.nonce,\n                    hash\n                });\n            } else {\n                this._observable.fire('no-share', {\n                    nonce: nonceRange.maxNonce\n                });\n            }\n            if (this._activeNonces.length > this.poolSize) {\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1);\n                return;\n            } else {\n                const newMin = Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n                const newRange = {minNonce: newMin, maxNonce: newMin + this._noncesPerRun};\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1, newRange);\n                nonceRange = newRange;\n            }\n        }\n        if (this._miningEnabled) {\n            setTimeout(() => this._singleMiner(nonceRange), this._cycleWait);\n        }\n    }\n}\n\nClass.register(MinerWorkerPool);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isWeb() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isNodeJs() {\n        return false;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        const RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection && typeof RTCPeerConnection.prototype.createDataChannel === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWS() {\n        return location && location.protocol === 'http:';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return !('onLine' in window.navigator) || window.navigator.onLine;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isWindows() {\n        return /^win/.test(window.navigator.platform);\n    }\n\n    static get userAgentString() {\n        try {\n            return window.navigator.platform;\n        } catch (e) {\n            return 'unknown';\n        }\n    }\n\n    static get hardwareConcurrency() {\n        if (typeof navigator === 'object' && navigator.hardwareConcurrency) {\n            return navigator.hardwareConcurrency;\n        } else {\n            return 1;\n        }\n    }\n}\n\nClass.register(PlatformUtils);\n","class WasmHelper {\n\n    static async doImport() {\n        return WasmHelper.doImportBrowser();\n    }\n\n    static async doImportBrowser() {\n        WasmHelper._importBrowserPromise = WasmHelper._importBrowserPromise || (async () => {\n            if (await WasmHelper.importWasmBrowser('worker-wasm.wasm')) {\n                await WasmHelper.importScriptBrowser('worker-wasm.js');\n            } else {\n                await WasmHelper.importScriptBrowser('worker-js.js');\n            }\n        })();\n        try {\n            await WasmHelper._importBrowserPromise;\n        } catch (e) {\n            WasmHelper._importBrowserPromise = null;\n            throw e;\n        }\n    }\n\n    /**\n     * @param {string} wasm\n     * @param {string} module\n     * @returns {Promise.<boolean>}\n     */\n    static async importWasm(wasm, module = 'Module') {\n        return WasmHelper.importWasmBrowser(wasm, module);\n    }\n\n    /**\n     * @param {string} wasm\n     * @param {string} module\n     * @returns {Promise.<boolean>}\n     */\n    static async importWasmBrowser(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return Promise.resolve(false);\n        }\n\n        return new Promise((resolve) => {\n            try {\n                const xhr = new XMLHttpRequest();\n                xhr.open('GET', wasm, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function () {\n                    WasmHelper._global[module] = WasmHelper._global[module] || {};\n                    WasmHelper._global[module].wasmBinary = xhr.response;\n                    resolve(true);\n                };\n                xhr.onerror = function () {\n                    Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                    resolve(false);\n                };\n                xhr.send(null);\n            } catch (e) {\n                Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                resolve(false);\n            }\n        });\n    }\n\n    static async importScript(script, module = 'Module') {\n        return WasmHelper.importScriptBrowser(script, module);\n    }\n\n    static async importScriptBrowser(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n        return new Promise(async (resolve, reject) => {\n            const runtimeInitialized = new Promise((resolve) => {\n                moduleSettings.onRuntimeInitialized = () => resolve(true);\n            });\n            if (typeof importScripts === 'function') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    importScripts(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n            } else if (typeof window === 'object') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    WasmHelper._loadBrowserScript(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n            } else if (typeof require === 'function') {\n                WasmHelper._global[module] = require(script)(moduleSettings);\n            } else {\n                reject('No way to load scripts.');\n                return;\n            }\n            await runtimeInitialized;\n            if (moduleSettings.asm && !WasmHelper._global[module].asm) WasmHelper._global[module] = moduleSettings;\n            resolve(true);\n        });\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof WasmHelper._moduleLoadedCallbacks[module] === 'function') {\n            WasmHelper._moduleLoadedCallbacks[module]();\n            WasmHelper._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url) {\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        head.appendChild(script);\n    }\n\n    static _adjustWasmPath(wasm) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n        if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n        return wasm;\n    }\n\n    static _adjustScriptPath(script) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n        if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n        return script;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n}\n\nWasmHelper._moduleLoadedCallbacks = {};\n\nClass.register(WasmHelper);\n","class GenesisConfig {}\nClass.register(GenesisConfig);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} [begin]\n     * @param {number} [end]\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @yields {Array}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nClass.register(Assert);\n","class MerkleTree {\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    static computeRoot(values, fnHash = MerkleTree._hash) {\n        return MerkleTree._computeRoot(values, fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} fnHash\n     * @returns {Hash}\n     * @private\n     */\n    static _computeRoot(values, fnHash) {\n        const len = values.length;\n        if (len === 0) {\n            return Hash.light(new Uint8Array(0));\n        }\n        if (len === 1) {\n            return fnHash(values[0]);\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const leftHash = MerkleTree._computeRoot(left, fnHash);\n        const rightHash = MerkleTree._computeRoot(right, fnHash);\n        return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n    }\n\n    /**\n     * @param {Hash|Uint8Array|{hash: function():Hash}|{serialize: function():Uint8Array}} o\n     * @returns {Hash}\n     * @private\n     */\n    static _hash(o) {\n        if (o instanceof Hash) {\n            return o;\n        }\n        if (typeof o.hash === 'function') {\n            return o.hash();\n        }\n        if (typeof o.serialize === 'function') {\n            return Hash.light(o.serialize());\n        }\n        if (o instanceof Uint8Array) {\n            return Hash.light(o);\n        }\n        throw new Error('MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method');\n    }\n}\nClass.register(MerkleTree);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Lunas\n     */\n    static coinsToLunas(coins) {\n        return Math.round(coins * Policy.LUNAS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} lunas Number of Lunas.\n     * @return {number} Nimiq count in decimal.\n     */\n    static lunasToCoins(lunas) {\n        return lunas / Policy.LUNAS_PER_COIN;\n    }\n\n    /**\n     * @deprecated Use coinsToLunas instead\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis (Lunas)\n     */\n    static coinsToSatoshis(coins) {\n        return Policy.coinsToLunas(coins);\n    }\n\n    /**\n     * @deprecated Use lunasToCoins instead\n     * @param {number} satoshis Number of Lunas.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return Policy.lunasToCoins(satoshis);\n    }\n\n    /**\n     * @deprecated Use LUNAS_PER_COIN instead\n     * @type {number}\n     * @constant\n     */\n    static get SATOSHIS_PER_COIN() {\n        return Policy.LUNAS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e5; // 100 kb\n\n/**\n * The highest (easiest) block PoW target.\n * @type {BigNumber}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = new BigNumber(2).pow(240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.LUNAS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in lunas.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in lunas.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in lunas until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.15;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Serializable {\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Serializable && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return BufferUtils.compare(this.serialize(), o.serialize());\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Serializable);\n","class Hash extends Serializable {\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        } else {\n            if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n            if (arg.length !== Hash.getSize(algorithm)) throw new Error('Primitive: Invalid length');\n        }\n        super();\n        this._obj = arg;\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Hash.computeBlake2b(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await (await CryptoWorker.getInstanceAsync()).computeArgon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Hash.computeSha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha512(arr) {\n        return new Hash(Hash.computeSha512(arr), Hash.Algorithm.SHA512);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        // !! The algorithms supported by this function are the allowed hash algorithms for HTLCs !!\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.SHA512 postponed until hard-fork\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} [begin]\n     * @param {number} [end]\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {Hash|Uint8Array|string} hash\n     * @param {Hash.Algorithm} algorithm\n     * @return {Hash}\n     */\n    static fromAny(hash, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (hash instanceof Hash) return hash;\n        try {\n            return new Hash(BufferUtils.fromAny(hash, Hash.SIZE.get(algorithm)), algorithm);\n        } catch (e) {\n            throw new Error('Invalid hash format');\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    toPlain() {\n        return this.toHex();\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Hash}\n     */\n    static fromPlain(str) {\n        return Hash.fromString(str);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Hash}\n     */\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (typeof size !== 'number') throw new Error('Invalid hash algorithm');\n        return size;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeBlake2b(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));\n            NodeNative.node_blake2(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.BLAKE2B);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeSha256(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));\n            NodeNative.node_sha256(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA256);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeSha512(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));\n            NodeNative.node_sha512(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA512);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                Module._nimiq_sha512(wasmOut, wasmIn, input.length);\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3,\n    SHA512: 4\n};\n/**\n * @param {Hash.Algorithm} hashAlgorithm\n * @return {string}\n */\nHash.Algorithm.toString = function(hashAlgorithm) {\n    switch (hashAlgorithm) {\n        case Hash.Algorithm.BLAKE2B: return 'blake2b';\n        case Hash.Algorithm.ARGON2D: return 'argon2d';\n        case Hash.Algorithm.SHA256: return 'sha256';\n        case Hash.Algorithm.SHA512: return 'sha512';\n    }\n    throw new Error('Invalid hash algorithm');\n};\n\n/**\n * @param {Hash.Algorithm|string} algorithm\n * @returns {Hash.Algorithm}\n */\nHash.Algorithm.fromAny = function (algorithm) {\n    if (typeof algorithm === 'number') return algorithm;\n    switch (algorithm) {\n        case 'blake2b': return Hash.Algorithm.BLAKE2B;\n        case 'argon2d': return Hash.Algorithm.ARGON2D;\n        case 'sha256': return Hash.Algorithm.SHA256;\n        case 'sha512': return Hash.Algorithm.SHA512;\n    }\n    throw new Error('Invalid hash algorithm');\n};\n\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, 32);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, 32);\nHash.SIZE.set(Hash.Algorithm.SHA256, 32);\nHash.SIZE.set(Hash.Algorithm.SHA512, 64);\n\nHash.NULL = new Hash(new Uint8Array(32));\nClass.register(Hash);\n","class PublicKey extends Serializable {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PublicKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(PublicKey._publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return PublicKey._delinearizeAndAggregatePublicKeys(publicKeys);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(buf.read(PublicKey.SIZE));\n    }\n\n    /**\n     * @param {PublicKey|Uint8Array|string} o\n     * @return {PublicKey}\n     */\n    static fromAny(o) {\n        if (!o) throw new Error('Invalid public key format');\n        if (o instanceof PublicKey) return o;\n        try {\n            return new PublicKey(BufferUtils.fromAny(o, PublicKey.SIZE));\n        } catch (e) {\n            throw new Error('Invalid public key format');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PublicKey.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @returns {PublicKey}\n     */\n    static _delinearizeAndAggregatePublicKeys(publicKeys) {\n        const publicKeysObj = publicKeys.map(k => k.serialize());\n        const publicKeysHash = PublicKey._publicKeysHash(publicKeysObj);\n        const raw = PublicKey._publicKeysDelinearizeAndAggregate(publicKeysObj, publicKeysHash);\n        return new PublicKey(raw);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDerive(privateKey) {\n        if (privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_public_key_derive(out, new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOut, PrivateKey.SIZE);\n                pubKeyBuffer.set(privateKey);\n                const wasmIn = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmIn, PrivateKey.SIZE);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_public_key_derive(wasmOut, wasmIn);\n                privKeyBuffer.fill(0);\n                const publicKey = new Uint8Array(PublicKey.SIZE);\n                publicKey.set(pubKeyBuffer);\n                return publicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static _publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));\n            NodeNative.node_ed25519_hash_public_keys(out, concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA512);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n                const hashedPublicKey = new Uint8Array(hashSize);\n                hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hashedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_delinearize_public_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n                const delinearizedPublicKey = new Uint8Array(PublicKey.SIZE);\n                delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return delinearizedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_delinearized_public_keys(out, new Uint8Array(publicKeysHash), concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n                const aggregatePublicKey = new Uint8Array(PublicKey.SIZE);\n                aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggregatePublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPublicKey.SIZE = 32;\n\nClass.register(PublicKey);\n","class Signature extends Serializable {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Signature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Signature._signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        const raw = Signature._combinePartialSignatures(commitment.serialize(), signatures.map(s => s.serialize()));\n        return new Signature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(buf.read(Signature.SIZE));\n    }\n\n    /**\n     * @param {Signature|Uint8Array|string} o\n     * @return {Signature}\n     */\n    static fromAny(o) {\n        if (!o) throw new Error('Invalid signature format');\n        if (o instanceof Signature) return o;\n        try {\n            return new Signature(BufferUtils.fromAny(o, Signature.SIZE));\n        } catch (e) {\n            throw new Error('Invalid signature format');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Signature.SIZE;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Signature._signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Signature._aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _aggregatePartialSignatures(partialSignatures) {\n        return partialSignatures.reduce((sigA, sigB) => Signature._scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    static _scalarsAdd(a, b) {\n        if (a.byteLength !== PartialSignature.SIZE || b.byteLength !== PartialSignature.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_add_scalars(out, new Uint8Array(a), new Uint8Array(b));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSum = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInA = Module.stackAlloc(a.length);\n                const wasmInB = Module.stackAlloc(b.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n                Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n                const sum = new Uint8Array(PartialSignature.SIZE);\n                sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, PartialSignature.SIZE));\n                return sum;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _signatureCreate(privateKey, publicKey, message) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Signature.SIZE);\n            NodeNative.node_ed25519_sign(out, new Uint8Array(message), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSignature = Module.stackAlloc(Signature.SIZE);\n                const signatureBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOutSignature, Signature.SIZE);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInPrivKey = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmInPrivKey, privateKey.length);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_sign(wasmOutSignature, wasmInMessage, message.byteLength, wasmInPubKey, wasmInPrivKey);\n                privKeyBuffer.fill(0);\n\n                const signature = new Uint8Array(Signature.SIZE);\n                signature.set(signatureBuffer);\n                return signature;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static _signatureVerify(publicKey, message, signature) {\n        if (PlatformUtils.isNodeJs()) {\n            return !!NodeNative.node_ed25519_verify(new Uint8Array(signature), new Uint8Array(message), new Uint8Array(publicKey));\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInSignature = Module.stackAlloc(signature.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInSignature, signature.length).set(signature);\n\n                return !!Module._ed25519_verify(wasmInSignature, wasmInMessage, message.byteLength, wasmInPubKey);\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nSignature.SIZE = 64;\n\nClass.register(Signature);\n","class Address extends Serializable {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Address.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} [begin]\n     * @param {number} [end]\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    /**\n     * @param {Address|string} addr\n     */\n    static fromAny(addr) {\n        if (addr instanceof Address) return addr;\n        if (typeof addr === 'string') return Address.fromString(addr);\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @returns {string}\n     */\n    toPlain() {\n        return this.toUserFriendlyAddress();\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @param {Account|object} o\n     */\n    static fromAny(o) {\n        if (o instanceof Account) return o;\n        return Account.fromPlain(o);\n    }\n\n    /**\n     * @param {object} plain\n     * @returns {Account}\n     */\n    static fromPlain(plain) {\n        if (!plain || plain.type === undefined) throw new Error('Invalid account');\n        const type = Account.Type.fromAny(plain.type);\n        return Account.TYPE_MAP.get(type).fromPlain(plain);\n    }\n\n    /**\n     * @returns {object}\n     */\n    toPlain() {\n        return {\n            type: Account.Type.toString(this.type),\n            balance: this.balance\n        };\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Account.BalanceError();\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Account.ValidityError();\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Account.DoubleTransactionError();\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Account.ValidityError();\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Account.BalanceError();\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @return {object}\n     */\n    static dataToPlain(data) {\n        return {};\n    }\n\n    /**\n     * @param {Uint8Array} proof\n     * @return {object}\n     */\n    static proofToPlain(proof) {\n        return {};\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @param {Account.Type} type\n * @return {string}\n */\nAccount.Type.toString = function(type) {\n    switch (type) {\n        case Account.Type.BASIC: return 'basic';\n        case Account.Type.VESTING: return 'vesting';\n        case Account.Type.HTLC: return 'htlc';\n    }\n    throw new Error('Invalid account type');\n};\n/**\n * @param {Account.Type|string} type\n * @return {Account.Type}\n */\nAccount.Type.fromAny = function(type) {\n    if (typeof type === 'number') return type;\n    switch (type) {\n        case 'basic': return Account.Type.BASIC;\n        case 'vesting': return Account.Type.VESTING;\n        case 'htlc': return Account.Type.HTLC;\n    }\n    throw new Error('Invalid account type');\n};\n/**\n * @type {Map.<Account.Type, {\n *  copy: function(o: *):Account,\n *  unserialize: function(buf: SerialBuffer):Account,\n *  create: function(balance: number, blockHeight: number, transaction: Transaction):Account,\n *  verifyOutgoingTransaction: function(transaction: Transaction):boolean,\n *  verifyIncomingTransaction: function(transaction: Transaction):boolean,\n *  fromPlain: function(o: object):Account,\n *  dataToPlain: function(data: Uint8Array):object,\n *  proofToPlain: function(proof: Uint8Array):object\n * }>}\n */\nAccount.TYPE_MAP = new Map();\nAccount.BalanceError = class extends Error { constructor() { super('Balance Error!'); }};\nAccount.DoubleTransactionError = class extends Error { constructor() { super('Double Transaction Error!'); }};\nAccount.ProofError = class extends Error { constructor() { super('Proof Error!'); }};\nAccount.ValidityError = class extends Error { constructor() { super('Validity Error!'); }};\nClass.register(Account);\n","class PrunedAccount {\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    constructor(address, account) {\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n\n        /** @type {Address} */\n        this._address = address;\n        /** @type {Account} */\n        this._account = account;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PrunedAccount}\n     */\n    static unserialize(buf) {\n        return new PrunedAccount(Address.unserialize(buf), Account.unserialize(buf));\n    }\n\n    /**\n     * @param {PrunedAccount|object} o\n     * @returns {PrunedAccount}\n     */\n    static fromAny(o) {\n        if (o instanceof PrunedAccount) return o;\n        return PrunedAccount.fromPlain(o);\n    }\n\n    /**\n     * @param {object} plain\n     */\n    static fromPlain(plain) {\n        return new PrunedAccount(Address.fromAny(plain.address), Account.fromAny(plain.account));\n    }\n\n    /**\n     * @param {PrunedAccount} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return this._address.compare(o._address);\n    }\n\n    /**\n     * @returns {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        return this._account;\n    }\n\n    /**\n     * @param buf\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._address.serialize(buf);\n        this._account.serialize(buf);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get serializedSize() {\n        return this._address.serializedSize + this._account.serializedSize;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._address.hashCode();\n    }\n\n    /**\n     * @returns {object}\n     */\n    toPlain() {\n        return {\n            address: this.address.toPlain(),\n            account: this.account.toPlain()\n        };\n    }\n}\n\nClass.register(PrunedAccount);\n","/**\n * This is a classic account that can send all his funds and receive any transaction.\n * All outgoing transactions are signed using the key corresponding to this address.\n */\nclass BasicAccount extends Account {\n    /**\n     * @param {BasicAccount} o\n     * @returns {BasicAccount}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new BasicAccount(o._balance);\n    }\n\n    /**\n     * @param {number} [balance]\n     */\n    constructor(balance = 0) {\n        super(Account.Type.BASIC, balance);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BasicAccount}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.BASIC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {object} o\n     */\n    static fromPlain(o) {\n        if (!o) throw new Error('Invalid account');\n        return new BasicAccount(o.balance);\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof BasicAccount\n            && this._type === o._type\n            && this._balance === o._balance;\n    }\n\n    toString() {\n        return `BasicAccount{balance=${this._balance}}`;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        return SignatureProof.verifyTransaction(transaction);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (transaction.data.byteLength > 64) return false;\n        return true;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            const isContractCreation = transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION);\n            const isTypeChange = transaction.recipientType !== this._type;\n            if (isContractCreation !== isTypeChange) {\n                throw new Error('Data Error!');\n            }\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.recipientType !== this._type && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract creation\n            return Account.TYPE_MAP.get(transaction.recipientType).create(this._balance, blockHeight, transaction);\n        }\n        return this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this._balance === 0;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @return {object}\n     */\n    static dataToPlain(data) {\n        return Account.dataToPlain(data);\n    }\n\n    /**\n     * @param {Uint8Array} proof\n     * @return {object}\n     */\n    static proofToPlain(proof) {\n        try {\n            const signatureProof = SignatureProof.unserialize(new SerialBuffer(proof));\n            return {\n                signature: signatureProof.signature.toHex(),\n                publicKey: signatureProof.publicKey.toHex(),\n                signer: signatureProof.publicKey.toAddress().toPlain(),\n                pathLength: signatureProof.merklePath.nodes.length\n            };\n        } catch (e) {\n            return Account.proofToPlain(proof);\n        }\n    }\n}\n\nAccount.INITIAL = new BasicAccount(0);\nAccount.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);\nClass.register(BasicAccount);\n","class Contract extends Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        super(type, balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract already created\n            throw new Error('Data error');\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Revert contract creation\n            return new BasicAccount(this.balance);\n        }\n        return this;\n    }\n}\n\nClass.register(Contract);\n","class HashedTimeLockedContract extends Contract {\n    /**\n     * @param {number} balance\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {Hash} hashRoot\n     * @param {number} hashCount\n     * @param {number} timeout\n     * @param {number} totalAmount\n     */\n    constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {\n        super(Account.Type.HTLC, balance);\n        if (!(sender instanceof Address)) throw new Error('Malformed sender address');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient address');\n        if (!(hashRoot instanceof Hash)) throw new Error('Malformed hashRoot');\n        if (!NumberUtils.isUint8(hashCount) || hashCount === 0) throw new Error('Malformed hashCount');\n        if (!NumberUtils.isUint32(timeout)) throw new Error('Malformed timeout');\n        if (!NumberUtils.isUint64(totalAmount)) throw new Error('Malformed totalAmount');\n\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Hash} */\n        this._hashRoot = hashRoot;\n        /** @type {number} */\n        this._hashCount = hashCount;\n        /** @type {number} */\n        this._timeout = timeout;\n        /** @type {number} */\n        this._totalAmount = totalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        const buf = new SerialBuffer(transaction.data);\n\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HashedTimeLockedContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.HTLC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n        const totalAmount = buf.readUint64();\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);\n    }\n\n    /**\n     * @param {object} plain\n     */\n    static fromPlain(plain) {\n        if (!plain) throw new Error('Invalid account');\n        return new HashedTimeLockedContract(plain.balance, Address.fromAny(plain.sender), Address.fromAny(plain.recipient), Hash.fromAny(plain.hashRoot, Hash.Algorithm.fromAny(plain.hashAlgorithm)), plain.hashCount, plain.timeout, plain.totalAmount);\n    }\n\n\n    /**\n     * Serialize this HTLC object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._sender.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._hashRoot.algorithm);\n        this._hashRoot.serialize(buf);\n        buf.writeUint8(this._hashCount);\n        buf.writeUint32(this._timeout);\n        buf.writeUint64(this._totalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._sender.serializedSize\n            + this._recipient.serializedSize\n            + /*hashAlgorithm*/ 1\n            + this._hashRoot.serializedSize\n            + /*hashCount*/ 1\n            + /*timeout*/ 4\n            + /*totalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get hashAlgorithm() {\n        return this._hashRoot.algorithm;\n    }\n\n    /** @type {Hash} */\n    get hashRoot() {\n        return this._hashRoot;\n    }\n\n    /** @type {number} */\n    get hashCount() {\n        return this._hashCount;\n    }\n\n    /** @type {number} */\n    get timeout() {\n        return this._timeout;\n    }\n\n    /** @type {number} */\n    get totalAmount() {\n        return this._totalAmount;\n    }\n\n    toString() {\n        return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;\n    }\n\n    /**\n     * @returns {object}\n     */\n    toPlain() {\n        const plain = super.toPlain();\n        plain.sender = this.sender.toPlain();\n        plain.recipient = this.recipient.toPlain();\n        plain.hashAlgorithm = Hash.Algorithm.toString(this.hashRoot.algorithm);\n        plain.hashRoot = this.hashRoot.toPlain();\n        plain.hashCount = this.hashCount;\n        plain.timeout = this.timeout;\n        plain.totalAmount = this.totalAmount;\n        return plain;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof HashedTimeLockedContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._sender.equals(o._sender)\n            && this._recipient.equals(o._recipient)\n            && this._hashRoot.equals(o._hashRoot)\n            && this._hashCount === o._hashCount\n            && this._timeout === o._timeout\n            && this._totalAmount === o._totalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    let preImage = Hash.unserialize(buf, hashAlgorithm);\n\n                    // Verify that the preImage hashed hashDepth times matches the _provided_ hashRoot.\n                    for (let i = 0; i < hashDepth; ++i) {\n                        preImage = Hash.compute(preImage.array, hashAlgorithm);\n                    }\n                    if (!hashRoot.equals(preImage)) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            // Reject overlong proof.\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return true; // Accept\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.data);\n\n            Address.unserialize(buf); // sender address\n            Address.unserialize(buf); // recipient address\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            Hash.unserialize(buf, hashAlgorithm);\n            const hashCount = buf.readUint8(); // hash count\n            buf.readUint32(); // timeout\n\n            if (hashCount === 0) {\n                return false;\n            }\n\n            // Blacklist Argon2 hash function.\n            if (hashAlgorithm === Hash.Algorithm.ARGON2D) {\n                return false;\n            }\n\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return Contract.verifyIncomingTransaction(transaction);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        const buf = new SerialBuffer(transaction.proof);\n        const type = buf.readUint8();\n        let minCap = 0;\n        switch (type) {\n            case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                // Check that the contract has not expired yet.\n                if (this._timeout < blockHeight) {\n                    throw new Account.ProofError();\n                }\n\n                // Check that the provided hashRoot is correct.\n                const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                const hashDepth = buf.readUint8();\n                const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                if (!hashRoot.equals(this._hashRoot)) {\n                    throw new Account.ProofError();\n                }\n\n                // Ignore the preImage.\n                Hash.unserialize(buf, hashAlgorithm);\n\n                // Verify that the transaction is signed by the authorized recipient.\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Account.ProofError();\n                }\n\n                minCap = Math.max(0, Math.floor((1 - (hashDepth / this._hashCount)) * this._totalAmount));\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Account.ProofError();\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Account.ProofError();\n                }\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                if (this._timeout >= blockHeight) {\n                    throw new Account.ProofError();\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Account.ProofError();\n                }\n\n                break;\n            }\n            default:\n                throw new Account.ProofError();\n        }\n\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Account.BalanceError();\n            }\n        }\n\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @return {object}\n     */\n    static dataToPlain(data) {\n        try {\n            const buf = new SerialBuffer(data);\n\n            const sender = Address.unserialize(buf);\n            const recipient = Address.unserialize(buf);\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n            const hashCount = buf.readUint8();\n            const timeout = buf.readUint32();\n\n            return {\n                sender: sender.toPlain(),\n                recipient: recipient.toPlain(),\n                hashAlgorithm: Hash.Algorithm.toString(hashAlgorithm),\n                hashRoot: hashRoot.toPlain(),\n                hashCount,\n                timeout\n            };\n        } catch (e) {\n            return Account.dataToPlain(data);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} proof\n     * @return {object}\n     */\n    static proofToPlain(proof) {\n        try {\n            const buf = new SerialBuffer(proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    const preImage = Hash.unserialize(buf, hashAlgorithm);\n                    const signatureProof = SignatureProof.unserialize(buf);\n\n                    return {\n                        type: HashedTimeLockedContract.ProofType.toString(type),\n                        hashAlgorithm: Hash.Algorithm.toString(hashAlgorithm),\n                        hashDepth,\n                        hashRoot: hashRoot.toPlain(),\n                        preImage: preImage.toPlain(),\n                        signer: signatureProof.publicKey.toAddress().toPlain(),\n                        signature: signatureProof.signature.toHex(),\n                        publicKey: signatureProof.publicKey.toHex(),\n                        pathLength: signatureProof.merklePath.nodes.length\n                    };\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    const signatureProof = SignatureProof.unserialize(buf);\n                    const creatorSignatureProof = SignatureProof.unserialize(buf);\n                    return {\n                        type: HashedTimeLockedContract.ProofType.toString(type),\n                        signer: signatureProof.publicKey.toAddress().toPlain(),\n                        signature: signatureProof.signature.toHex(),\n                        publicKey: signatureProof.publicKey.toHex(),\n                        pathLength: signatureProof.merklePath.nodes.length,\n                        creator: creatorSignatureProof.publicKey.toAddress().toPlain(),\n                        creatorSignature: creatorSignatureProof.signature.toHex(),\n                        creatorPublicKey: creatorSignatureProof.publicKey.toHex(),\n                        creatorPathLength: creatorSignatureProof.merklePath.nodes.length\n                    };\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                    const creatorSignatureProof = SignatureProof.unserialize(buf);\n                    return {\n                        type: HashedTimeLockedContract.ProofType.toString(type),\n                        creator: creatorSignatureProof.publicKey.toAddress().toPlain(),\n                        creatorSignature: creatorSignatureProof.signature.toHex(),\n                        creatorPublicKey: creatorSignatureProof.publicKey.toHex(),\n                        creatorPathLength: creatorSignatureProof.merklePath.nodes.length\n                    };\n                }\n                default:\n                    return false;\n            }\n        } catch (e) {\n            return Account.proofToPlain(proof);\n        }\n    }\n}\n\nHashedTimeLockedContract.ProofType = {\n    REGULAR_TRANSFER: 1,\n    EARLY_RESOLVE: 2,\n    TIMEOUT_RESOLVE: 3\n};\n\n/**\n * @param {HashedTimeLockedContract.ProofType} proofType\n * @return {string}\n */\nHashedTimeLockedContract.ProofType.toString = function(proofType) {\n    switch (proofType) {\n        case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: return 'regular-transfer';\n        case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: return 'early-resolve';\n        case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: return 'timeout-resolve';\n    }\n    throw new Error('Invalid proof type');\n};\n\nAccount.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);\nClass.register(HashedTimeLockedContract);\n","class VestingContract extends Contract {\n    /**\n     * @param {number} [balance]\n     * @param {Address} [owner]\n     * @param {number} [vestingStart]\n     * @param {number} [vestingStepBlocks]\n     * @param {number} [vestingStepAmount]\n     * @param {number} [vestingTotalAmount]\n     */\n    constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {\n        super(Account.Type.VESTING, balance);\n        if (!(owner instanceof Address)) throw new Error('Malformed owner address');\n        if (!NumberUtils.isUint32(vestingStart)) throw new Error('Malformed vestingStart');\n        if (!NumberUtils.isUint32(vestingStepBlocks)) throw new Error('Malformed vestingStepBlocks');\n        if (!NumberUtils.isUint64(vestingStepAmount)) throw new Error('Malformed vestingStepAmount');\n        if (!NumberUtils.isUint64(vestingTotalAmount)) throw new Error('Malformed vestingTotalAmount');\n\n        /** @type {Address} */\n        this._owner = owner;\n        /** @type {number} */\n        this._vestingStart = vestingStart;\n        /** @type {number} */\n        this._vestingStepBlocks = vestingStepBlocks;\n        /** @type {number} */\n        this._vestingStepAmount = vestingStepAmount;\n        /** @type {number} */\n        this._vestingTotalAmount = vestingTotalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        /** @type {number} */\n        let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n        const buf = new SerialBuffer(transaction.data);\n        const owner = Address.unserialize(buf);\n        vestingTotalAmount = transaction.value;\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n                // Only block number: vest full amount at that block\n                vestingStart = 0;\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = vestingTotalAmount;\n                break;\n            case Address.SERIALIZED_SIZE + 16:\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                break;\n            case Address.SERIALIZED_SIZE + 24:\n                // Create a vesting account with some instantly vested funds or additional funds considered.\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                vestingTotalAmount = buf.readUint64();\n                break;\n            default:\n                throw new Error('Invalid transaction data');\n        }\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VestingContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.VESTING) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const owner = Address.unserialize(buf);\n        const vestingStart = buf.readUint32();\n        const vestingStepBlocks = buf.readUint32();\n        const vestingStepAmount = buf.readUint64();\n        const vestingTotalAmount = buf.readUint64();\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {object} plain\n     */\n    static fromPlain(plain) {\n        if (!plain) throw new Error('Invalid account');\n        return new VestingContract(plain.balance, Address.fromAny(plain.owner), plain.vestingStart, plain.vestingStepBlocks, plain.vestingStepAmount, plain.vestingTotalAmount);\n    }\n\n    /**\n     * Serialize this VestingContract object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._owner.serialize(buf);\n        buf.writeUint32(this._vestingStart);\n        buf.writeUint32(this._vestingStepBlocks);\n        buf.writeUint64(this._vestingStepAmount);\n        buf.writeUint64(this._vestingTotalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._owner.serializedSize\n            + /*vestingStart*/ 4\n            + /*vestingStepBlocks*/ 4\n            + /*vestingStepAmount*/ 8\n            + /*vestingTotalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get owner() {\n        return this._owner;\n    }\n\n    /** @type {number} */\n    get vestingStart() {\n        return this._vestingStart;\n    }\n\n    /** @type {number} */\n    get vestingStepBlocks() {\n        return this._vestingStepBlocks;\n    }\n\n    /** @type {number} */\n    get vestingStepAmount() {\n        return this._vestingStepAmount;\n    }\n\n    /** @type {number} */\n    get vestingTotalAmount() {\n        return this._vestingTotalAmount;\n    }\n\n    toString() {\n        return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;\n    }\n\n    /**\n     * @returns {object}\n     */\n    toPlain() {\n        const plain = super.toPlain();\n        plain.owner = this.owner.toPlain();\n        plain.vestingStart = this.vestingStart;\n        plain.vestingStepBlocks = this.vestingStepBlocks;\n        plain.vestingStepAmount = this.vestingStepAmount;\n        plain.vestingTotalAmount = this.vestingTotalAmount;\n        return plain;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof VestingContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._owner.equals(o._owner)\n            && this._vestingStart === o._vestingStart\n            && this._vestingStepBlocks === o._vestingStepBlocks\n            && this._vestingStepAmount === o._vestingStepAmount\n            && this._vestingTotalAmount === o._vestingTotalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        const buf = new SerialBuffer(transaction.proof);\n\n        if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n            return false;\n        }\n\n        if (buf.readPos !== buf.byteLength) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n            case Address.SERIALIZED_SIZE + 16:\n            case Address.SERIALIZED_SIZE + 24:\n                return Contract.verifyIncomingTransaction(transaction);\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const minCap = this.getMinCap(blockHeight);\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Account.BalanceError();\n            }\n\n            const buf = new SerialBuffer(transaction.proof);\n            if (!SignatureProof.unserialize(buf).isSignedBy(this._owner)) {\n                throw new Account.ProofError();\n            }\n        }\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @returns {number}\n     */\n    getMinCap(blockHeight) {\n        return this._vestingStepBlocks && this._vestingStepAmount > 0\n            ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount)\n            : 0;\n    }\n\n\n    /**\n     * @param {Uint8Array} data\n     * @return {object}\n     */\n    static dataToPlain(data) {\n        try {\n            let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n            const buf = new SerialBuffer(data);\n            const owner = Address.unserialize(buf);\n            switch (transaction.data.length) {\n                case Address.SERIALIZED_SIZE + 4:\n                    vestingStart = 0;\n                    vestingStepBlocks = buf.readUint32();\n                    break;\n                case Address.SERIALIZED_SIZE + 16:\n                    vestingStart = buf.readUint32();\n                    vestingStepBlocks = buf.readUint32();\n                    vestingStepAmount = buf.readUint64();\n                    break;\n                case Address.SERIALIZED_SIZE + 24:\n                    vestingStart = buf.readUint32();\n                    vestingStepBlocks = buf.readUint32();\n                    vestingStepAmount = buf.readUint64();\n                    vestingTotalAmount = buf.readUint64();\n                    break;\n                default:\n                    throw new Error('Invalid transaction data');\n            }\n            return {\n                owner: owner.toPlain(),\n                vestingStart,\n                vestingStepBlocks,\n                vestingStepAmount,\n                vestingTotalAmount\n            };\n        } catch (e) {\n            return Account.dataToPlain(data);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} proof\n     * @return {object}\n     */\n    static proofToPlain(proof) {\n        try {\n            const signatureProof = SignatureProof.unserialize(new SerialBuffer(proof));\n            return {\n                signature: signatureProof.signature.toHex(),\n                publicKey: signatureProof.publicKey.toHex(),\n                signer: signatureProof.publicKey.toAddress().toPlain(),\n                pathLength: signatureProof.merklePath.nodes.length\n            };\n        } catch (e) {\n            return Account.proofToPlain(proof);\n        }\n    }\n}\n\nAccount.TYPE_MAP.set(Account.Type.VESTING, VestingContract);\nClass.register(VestingContract);\n","class BlockHeader {\n    /**\n     * @param {Hash} prevHash\n     * @param {Hash} interlinkHash\n     * @param {Hash} bodyHash\n     * @param {Hash} accountsHash\n     * @param {number} nBits\n     * @param {number} height\n     * @param {number} timestamp\n     * @param {number} nonce\n     * @param {number} version\n     */\n    constructor(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version = BlockHeader.CURRENT_VERSION) {\n        if (!NumberUtils.isUint16(version)) throw new Error('Malformed version');\n        if (!Hash.isHash(prevHash)) throw new Error('Malformed prevHash');\n        if (!Hash.isHash(interlinkHash)) throw new Error('Malformed interlinkHash');\n        if (!Hash.isHash(bodyHash)) throw new Error('Malformed bodyHash');\n        if (!Hash.isHash(accountsHash)) throw new Error('Malformed accountsHash');\n        if (!NumberUtils.isUint32(nBits) || !BlockUtils.isValidCompact(nBits)) throw new Error('Malformed nBits');\n        if (!NumberUtils.isUint32(height)) throw new Error('Invalid height');\n        if (!NumberUtils.isUint32(timestamp)) throw new Error('Malformed timestamp');\n        if (!NumberUtils.isUint32(nonce)) throw new Error('Malformed nonce');\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._prevHash = prevHash;\n        /** @type {Hash} */\n        this._interlinkHash = interlinkHash;\n        /** @type {Hash} */\n        this._bodyHash = bodyHash;\n        /** @type {Hash} */\n        this._accountsHash = accountsHash;\n        /** @type {number} */\n        this._nBits = nBits;\n        /** @type {number} */\n        this._height = height;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockHeader}\n     */\n    static unserialize(buf) {\n        const version = buf.readUint16();\n        if (!BlockHeader.SUPPORTED_VERSIONS.includes(version)) throw new Error(`Unsupported block version ${version}`);\n        const prevHash = Hash.unserialize(buf);\n        const interlinkHash = Hash.unserialize(buf);\n        const bodyHash = Hash.unserialize(buf);\n        const accountsHash = Hash.unserialize(buf);\n        const nBits = buf.readUint32();\n        const height = buf.readUint32();\n        const timestamp = buf.readUint32();\n        const nonce = buf.readUint32();\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._version);\n        this._prevHash.serialize(buf);\n        this._interlinkHash.serialize(buf);\n        this._bodyHash.serialize(buf);\n        this._accountsHash.serialize(buf);\n        buf.writeUint32(this._nBits);\n        buf.writeUint32(this._height);\n        buf.writeUint32(this._timestamp);\n        buf.writeUint32(this._nonce);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*version*/ 2\n            + this._prevHash.serializedSize\n            + this._interlinkHash.serializedSize\n            + this._bodyHash.serializedSize\n            + this._accountsHash.serializedSize\n            + /*nBits*/ 4\n            + /*height*/ 4\n            + /*timestamp*/ 4\n            + /*nonce*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<boolean>}\n     */\n    async verifyProofOfWork(buf) {\n        const pow = await this.pow(buf);\n        return BlockUtils.isProofOfWork(pow, this.target);\n    }\n\n    /**\n     * @param {BlockHeader} prevHeader\n     * @returns {boolean}\n     */\n    isImmediateSuccessorOf(prevHeader) {\n        // Check that the height is one higher than the previous height.\n        if (this.height !== prevHeader.height + 1) {\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this.timestamp < prevHeader.timestamp) {\n            return false;\n        }\n\n        // Check that the hash of the predecessor block equals prevHash.\n        const prevHash = prevHeader.hash();\n        if (!this.prevHash.equals(prevHash)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Hash}\n     */\n    hash(buf) {\n        this._hash = this._hash || Hash.light(this.serialize(buf));\n        return this._hash;\n    }\n    \n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async pow(buf) {\n        this._pow = this._pow || await Hash.hard(this.serialize(buf));\n        return this._pow;\n    }\n\n    /**\n     * @param {BlockHeader|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockHeader\n            && this._prevHash.equals(o.prevHash)\n            && this._interlinkHash.equals(o.interlinkHash)\n            && this._bodyHash.equals(o.bodyHash)\n            && this._accountsHash.equals(o.accountsHash)\n            && this._nBits === o.nBits\n            && this._height === o.height\n            && this._timestamp === o.timestamp\n            && this._nonce === o.nonce;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return 'BlockHeader{'\n            + `prevHash=${this._prevHash}, `\n            + `interlinkHash=${this._interlinkHash}, `\n            + `bodyHash=${this._bodyHash}, `\n            + `accountsHash=${this._accountsHash}, `\n            + `nBits=${this._nBits.toString(16)}, `\n            + `height=${this._height}, `\n            + `timestamp=${this._timestamp}, `\n            + `nonce=${this._nonce}`\n            + '}';\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get prevHash() {\n        return this._prevHash;\n    }\n\n    /** @type {Hash} */\n    get interlinkHash() {\n        return this._interlinkHash;\n    }\n\n    /** @type {Hash} */\n    get bodyHash() {\n        return this._bodyHash;\n    }\n\n    /** @type {Hash} */\n    get accountsHash() {\n        return this._accountsHash;\n    }\n\n    /** @type {number} */\n    get nBits() {\n        return this._nBits;\n    }\n\n    /** @type {BigNumber} */\n    get target() {\n        return BlockUtils.compactToTarget(this._nBits);\n    }\n\n    /** @type {BigNumber} */\n    get difficulty() {\n        return BlockUtils.compactToDifficulty(this._nBits);\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._height;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    // XXX The miner changes the nonce of an existing BlockHeader during the\n    // mining process.\n    /** @type {number} */\n    set nonce(n) {\n        this._nonce = n;\n        this._hash = null;\n        this._pow = null;\n    }\n}\nBlockHeader.Version = {\n    V1: 1\n};\nBlockHeader.CURRENT_VERSION = BlockHeader.Version.V1;\nBlockHeader.SUPPORTED_VERSIONS = [\n    BlockHeader.Version.V1\n];\nBlockHeader.SERIALIZED_SIZE = 146;\nClass.register(BlockHeader);\n","class BlockInterlink {\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} prevHash\n     * @returns {{repeatBits: Uint8Array, compressed: Array.<Hash>}}\n     * @protected\n     */\n    static _compress(hashes, prevHash) {\n        const count = hashes.length;\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = new Uint8Array(repeatBitsSize);\n\n        let lastHash = prevHash;\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const hash = hashes[i];\n            if (!hash.equals(lastHash)) {\n                compressed.push(hash);\n                lastHash = hash;\n            } else {\n                repeatBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return {repeatBits, compressed};\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} [prevHash]\n     * @param {Uint8Array} [repeatBits]\n     * @param {Array.<Hash>} [compressed]\n     */\n    constructor(hashes, prevHash, repeatBits, compressed) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint8(hashes.length)\n            || hashes.some(it => !(it instanceof Hash))) throw new Error('Malformed hashes');\n        if ((repeatBits || compressed) && !(repeatBits && compressed)) throw new Error('Malformed repeatBits/compressed');\n        if (!prevHash && !repeatBits) throw new Error('Either prevHash or repeatBits/compressed required');\n\n        if (!repeatBits) {\n            ({repeatBits, compressed} = BlockInterlink._compress(hashes, prevHash));\n        }\n\n        /** @type {Array.<Hash>} */\n        this._hashes = hashes;\n        /** @type {Uint8Array} */\n        this._repeatBits = repeatBits;\n        /** @type {Array.<Hash>} */\n        this._compressed = compressed;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash} prevHash\n     * @returns {BlockInterlink}\n     */\n    static unserialize(buf, prevHash) {\n        const count = buf.readUint8();\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = buf.read(repeatBitsSize);\n\n        let hash = prevHash;\n        const hashes = [];\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const repeated = (repeatBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            if (!repeated) {\n                hash = Hash.unserialize(buf);\n                compressed.push(hash);\n            }\n            hashes.push(hash);\n        }\n\n        return new BlockInterlink(hashes, prevHash, repeatBits, compressed);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._hashes.length);\n        buf.write(this._repeatBits);\n        for (const hash of this._compressed) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return /*count*/ 1\n            + this._repeatBits.length\n            + this._compressed.reduce((sum, hash) => sum + hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {BlockInterlink|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockInterlink\n            && this._hashes.length === o._hashes.length\n            && this._hashes.every((hash, i) => hash.equals(o.hashes[i]));\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot([this._repeatBits, GenesisConfig.GENESIS_HASH, ...this._compressed]);\n        }\n        return this._hash;\n    }\n\n    /**\n     * @type {Array.<Hash>}\n     */\n    get hashes() {\n        return this._hashes;\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._hashes.length;\n    }\n}\nClass.register(BlockInterlink);\n","class BlockBody {\n    /**\n     * @param {Uint8Array} extraData\n     * @returns {number}\n     */\n    static getMetadataSize(extraData) {\n        return Address.SERIALIZED_SIZE\n            + /*extraDataLength*/ 1\n            + extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n    }\n\n    /**\n     * @param {Address} minerAddr\n     * @param {Array.<Transaction>} transactions\n     * @param {Uint8Array} [extraData]\n     * @param {Array.<PrunedAccount>} prunedAccounts\n     */\n    constructor(minerAddr, transactions, extraData = new Uint8Array(0), prunedAccounts = []) {\n        if (!(minerAddr instanceof Address)) throw new Error('Malformed minerAddr');\n        if (!Array.isArray(transactions) || transactions.some(it => !(it instanceof Transaction))) throw new Error('Malformed transactions');\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint8(extraData.byteLength)) throw new Error('Malformed extraData');\n\n        /** @type {Address} */\n        this._minerAddr = minerAddr;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {Array.<PrunedAccount>} */\n        this._prunedAccounts = prunedAccounts;\n        /** @type {Hash} */\n        this._hash = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockBody}\n     */\n    static unserialize(buf) {\n        const minerAddr = Address.unserialize(buf);\n        const extraDataLength = buf.readUint8();\n        const extraData = buf.read(extraDataLength);\n        const numTransactions = buf.readUint16();\n        const transactions = new Array(numTransactions);\n        for (let i = 0; i < numTransactions; i++) {\n            transactions[i] = Transaction.unserialize(buf);\n        }\n        const numPrunedAccounts = buf.readUint16();\n        const prunedAccounts = [];\n        for (let i = 0; i < numPrunedAccounts; i++) {\n            prunedAccounts.push(PrunedAccount.unserialize(buf));\n        }\n        return new BlockBody(minerAddr, transactions, extraData, prunedAccounts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._minerAddr.serialize(buf);\n        buf.writeUint8(this._extraData.byteLength);\n        buf.write(this._extraData);\n        buf.writeUint16(this._transactions.length);\n        for (const tx of this._transactions) {\n            tx.serialize(buf);\n        }\n        buf.writeUint16(this._prunedAccounts.length);\n        for (const acc of this._prunedAccounts) {\n            acc.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        let size = this._minerAddr.serializedSize\n            + /*extraDataLength*/ 1\n            + this._extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n        for (const tx of this._transactions) {\n            size += tx.serializedSize;\n        }\n        size += this._prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Transaction} */\n        let previousTx = null;\n        for (const tx of this._transactions) {\n            // Ensure transactions are ordered and unique.\n            if (previousTx && previousTx.compareBlockOrder(tx) >= 0) {\n                Log.w(BlockBody, 'Invalid block - transactions not ordered.');\n                return false;\n            }\n            previousTx = tx;\n\n            // Check that all transactions are valid.\n            if (!tx.verify()) {\n                Log.w(BlockBody, 'Invalid block - invalid transaction');\n                return false;\n            }\n        }\n\n        let previousAcc = null;\n        for (const acc of this._prunedAccounts) {\n            // Ensure pruned accounts are ordered and unique.\n            if (previousAcc && previousAcc.compare(acc) >= 0) {\n                Log.w(BlockBody, 'Invalid block - pruned accounts not ordered.');\n                return false;\n            }\n            previousAcc = acc;\n            \n            // Check that pruned accounts are actually supposed to be pruned\n            if (!acc.account.isToBePruned()) {\n                Log.w(BlockBody, 'Invalid block - invalid pruned account');\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array}\n     */\n    getMerkleLeafs() {\n        return [this._minerAddr, this._extraData, ...this._transactions, ...this.prunedAccounts];\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot(this.getMerkleLeafs());\n        }\n        return this._hash;\n    }\n\n    /**\n     * @param {BlockBody} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockBody\n            && this._minerAddr.equals(o.minerAddr)\n            && BufferUtils.equals(this._extraData, o.extraData)\n            && this._transactions.length === o.transactions.length\n            && this._transactions.every((tx, i) => tx.equals(o.transactions[i]));\n    }\n\n    /**\n     * @return {Array.<Address>}\n     */\n    getAddresses() {\n        const addresses = [this._minerAddr];\n        for (const tx of this._transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        return addresses;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    /** @type {Address} */\n    get minerAddr() {\n        return this._minerAddr;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {number} */\n    get transactionCount() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<PrunedAccount>} */\n    get prunedAccounts() {\n        return this._prunedAccounts;\n    }\n}\n\nClass.register(BlockBody);\n","class BlockUtils {\n    /**\n     * @param {number} compact\n     * @returns {BigNumber}\n     */\n    static compactToTarget(compact) {\n        return new BigNumber(compact & 0xffffff).times(new BigNumber(2).pow(8 * Math.max((compact >> 24) - 3, 0)));\n    }\n\n    /**\n     * @param {BigNumber} target\n     * @returns {number}\n     */\n    static targetToCompact(target) {\n        if (!target.isFinite() || target.isNaN()) throw new Error('Invalid Target');\n\n        // Divide to get first byte\n        let size = Math.max(Math.ceil(Math.log2(target.toNumber()) / 8), 1);\n        const firstByte = target / Math.pow(2, (size - 1) * 8);\n\n        // If the first (most significant) byte is greater than 127 (0x7f),\n        // prepend a zero byte.\n        if (firstByte >= 0x80 && size >= 3) {\n            size++;\n        }\n\n        // The first byte of the 'compact' format is the number of bytes,\n        // including the prepended zero if it's present.\n        // The following three bytes are the first three bytes of the above\n        // representation. If less than three bytes are present, then one or\n        // more of the last bytes of the compact representation will be zero.\n        return (size << 24) + ((target / Math.pow(2, Math.max(size - 3, 0) * 8)) & 0xffffff);\n    }\n\n    /**\n     * @param {BigNumber} target\n     * @returns {number}\n     */\n    static getTargetHeight(target) {\n        // Precision loss should be ok here.\n        return Math.ceil(Math.log2(target.toNumber()));\n    }\n\n    /**\n     * @param {BigNumber} target\n     * @returns {number}\n     */\n    static getTargetDepth(target) {\n        return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX) - BlockUtils.getTargetHeight(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {BigNumber}\n     */\n    static compactToDifficulty(compact) {\n        return Policy.BLOCK_TARGET_MAX.div(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {BigNumber} difficulty\n     * @returns {number}\n     */\n    static difficultyToCompact(difficulty) {\n        return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(difficulty));\n    }\n\n    /**\n     * @param {BigNumber} difficulty\n     * @returns {BigNumber}\n     */\n    static difficultyToTarget(difficulty) {\n        return Policy.BLOCK_TARGET_MAX.div(difficulty);\n    }\n\n    /**\n     * @param {BigNumber} target\n     * @returns {BigNumber}\n     */\n    static targetToDifficulty(target) {\n        return Policy.BLOCK_TARGET_MAX.div(target);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {BigNumber}\n     */\n    static hashToTarget(hash) {\n        return new BigNumber(hash.toHex(), 16);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {BigNumber}\n     */\n    static realDifficulty(hash) {\n        return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static getHashDepth(hash) {\n        return BlockUtils.getTargetDepth(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BigNumber} target\n     * @returns {boolean}\n     */\n    static isProofOfWork(hash, target) {\n        return new BigNumber(hash.toHex(), 16).lte(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {boolean}\n     */\n\n    static isValidCompact(compact) {\n        return BlockUtils.isValidTarget(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {?BigNumber} target\n     * @returns {boolean}\n     */\n    static isValidTarget(target) {\n        return target !== null && target.gte(1) && target.lte(Policy.BLOCK_TARGET_MAX);\n    }\n\n    /**\n     * @param {BlockHeader} headBlock\n     * @param {BlockHeader} tailBlock\n     * @param {BigNumber} deltaTotalDifficulty\n     * @returns {BigNumber}\n     */\n    static getNextTarget(headBlock, tailBlock, deltaTotalDifficulty) {\n        Assert.that(\n            (headBlock.height - tailBlock.height === Policy.DIFFICULTY_BLOCK_WINDOW)\n                || (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW && tailBlock.height === 1),\n            `Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);\n\n        let actualTime = headBlock.timestamp - tailBlock.timestamp;\n\n        // Simulate that the Policy.BLOCK_TIME was achieved for the blocks before the genesis block, i.e. we simulate\n        // a sliding window that starts before the genesis block. Assume difficulty = 1 for these blocks.\n        if (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW) {\n            actualTime += (Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1) * Policy.BLOCK_TIME;\n            deltaTotalDifficulty = deltaTotalDifficulty.plus(Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1);\n        }\n\n        // Compute the target adjustment factor.\n        const expectedTime = Policy.DIFFICULTY_BLOCK_WINDOW * Policy.BLOCK_TIME;\n        let adjustment = actualTime / expectedTime;\n\n        // Clamp the adjustment factor to [1 / MAX_ADJUSTMENT_FACTOR, MAX_ADJUSTMENT_FACTOR].\n        adjustment = Math.max(adjustment, 1 / Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n        adjustment = Math.min(adjustment, Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n\n        // Compute the next target.\n        const averageDifficulty = deltaTotalDifficulty.div(Policy.DIFFICULTY_BLOCK_WINDOW);\n        const averageTarget = BlockUtils.difficultyToTarget(averageDifficulty);\n        let nextTarget = averageTarget.times(adjustment);\n\n        // Make sure the target is below or equal the maximum allowed target (difficulty 1).\n        // Also enforce a minimum target of 1.\n        nextTarget = BigNumber.min(nextTarget, Policy.BLOCK_TARGET_MAX);\n        nextTarget = BigNumber.max(nextTarget, 1);\n\n        // XXX Reduce target precision to nBits precision.\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        return BlockUtils.compactToTarget(nBits);\n    }\n}\nClass.register(BlockUtils);\n","class Block {\n    /**\n     * @param {BlockHeader} header\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} [body]\n     */\n    constructor(header, interlink, body) {\n        if (!(header instanceof BlockHeader)) throw new Error('Malformed header');\n        if (!(interlink instanceof BlockInterlink)) throw new Error('Malformed interlink');\n        if (body && !(body instanceof BlockBody)) throw new Error('Malformed body');\n\n        /** @type {BlockHeader} */\n        this._header = header;\n        /** @type {BlockInterlink} */\n        this._interlink = interlink;\n        /** @type {BlockBody} */\n        this._body = body;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Block}\n     */\n    static unserialize(buf) {\n        const header = BlockHeader.unserialize(buf);\n        const interlink = BlockInterlink.unserialize(buf, header.prevHash);\n\n        let body = undefined;\n        const bodyPresent = buf.readUint8();\n        if (bodyPresent) {\n            body = BlockBody.unserialize(buf);\n        }\n\n        return new Block(header, interlink, body);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._header.serialize(buf);\n        this._interlink.serialize(buf);\n\n        if (this._body) {\n            buf.writeUint8(1);\n            this._body.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._header.serializedSize\n            + this._interlink.serializedSize\n            + /*bodyPresent*/ 1\n            + (this._body ? this._body.serializedSize : 0);\n    }\n\n    /**\n     * @param {Time} time\n     * @returns {Promise.<boolean>}\n     */\n    async verify(time) {\n        if (this._valid === undefined) {\n            if (this.isLight() || this.body.transactions.length < 150 || !IWorker.areWorkersAsync) {\n                // worker overhead doesn't pay off for small transaction numbers\n                this._valid = await this._verify(time.now());\n            } else {\n                const transactionValid = this.body.transactions.map(t => t._valid);\n                const worker = await CryptoWorker.getInstanceAsync();\n                const {valid, pow, interlinkHash, bodyHash} = await worker.blockVerify(this.serialize(),\n                    transactionValid, time.now(), GenesisConfig.GENESIS_HASH.serialize(), GenesisConfig.NETWORK_ID);\n                this._valid = valid;\n                this.header._pow = Hash.unserialize(new SerialBuffer(pow));\n                this.interlink._hash = Hash.unserialize(new SerialBuffer(interlinkHash));\n                this.body._hash = Hash.unserialize(new SerialBuffer(bodyHash));\n            }\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} timeNow\n     * @returns {Promise.<boolean>}\n     */\n    async _verify(timeNow) {\n        // Check that the timestamp is not too far into the future.\n        if (this._header.timestamp * 1000 > timeNow + Block.TIMESTAMP_DRIFT_MAX * 1000) {\n            Log.w(Block, 'Invalid block - timestamp too far in the future');\n            return false;\n        }\n\n        // Check that the header hash matches the difficulty.\n        if (!(await this._header.verifyProofOfWork())) {\n            Log.w(Block, 'Invalid block - PoW verification failed');\n            return false;\n        }\n\n        // Check that the maximum block size is not exceeded.\n        if (this.serializedSize > Policy.BLOCK_SIZE_MAX) {\n            Log.w(Block, 'Invalid block - max block size exceeded');\n            return false;\n        }\n\n        // Verify that the interlink is valid.\n        if (!this._verifyInterlink()) {\n            return false;\n        }\n\n        // XXX Verify the body only if it is present.\n        if (this.isFull() && !this._verifyBody()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyInterlink() {\n        // Skip check for genesis block due to the cyclic dependency (since the interlink hash contains the genesis block hash).\n        if (this.height === 1 && this._header.interlinkHash.equals(new Hash(null))) {\n            return true;\n        }\n\n        // Check that the interlinkHash given in the header matches the actual interlinkHash.\n        const interlinkHash = this._interlink.hash();\n        if (!this._header.interlinkHash.equals(interlinkHash)) {\n            Log.w(Block, 'Invalid block - interlink hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyBody() {\n        // Check that the body is valid.\n        if (!this._body.verify()) {\n            return false;\n        }\n\n        // Check that bodyHash given in the header matches the actual body hash.\n        const bodyHash = this._body.hash();\n        if (!this._header.bodyHash.equals(bodyHash)) {\n            Log.w(Block, 'Invalid block - body hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isImmediateSuccessorOf(predecessor) {\n        // Check the header.\n        if (!this._header.isImmediateSuccessorOf(predecessor.header)) {\n            return false;\n        }\n\n        // Check that the interlink is correct.\n        const interlink = await predecessor.getNextInterlink(this.target, this.version);\n        if (!this._interlink.equals(interlink)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isInterlinkSuccessorOf(predecessor) {\n        // Check that the height is higher than the predecessor's.\n        if (this._header.height <= predecessor.header.height) {\n            Log.v(Block, 'No interlink successor - height');\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this._header.timestamp < predecessor.header.timestamp) {\n            Log.v(Block, 'No interlink successor - timestamp');\n            return false;\n        }\n\n        // Check that the predecessor is contained in this block's interlink and verify its position.\n        const prevHash = predecessor.hash();\n        if (!GenesisConfig.GENESIS_HASH.equals(prevHash)) {\n            const prevPow = await predecessor.pow();\n            const targetHeight = BlockUtils.getTargetHeight(this.target);\n            let blockFound = false;\n\n            let depth = 0;\n            for (; depth < this._interlink.length; depth++) {\n                if (prevHash.equals(this._interlink.hashes[depth])) {\n                    blockFound = true;\n                    const target = new BigNumber(2).pow(targetHeight - depth);\n                    if (!BlockUtils.isProofOfWork(prevPow, target)) {\n                        Log.v(Block, 'No interlink successor - invalid position in interlink');\n                        return false;\n                    }\n                }\n            }\n\n            if (!blockFound) {\n                Log.v(Block, 'No interlink successor - not in interlink');\n                return false;\n            }\n        }\n\n        // If the predecessor happens to be the immediate predecessor, check additionally:\n        // - that the height of the successor is one higher\n        // - that the interlink is correct.\n        if (this._header.prevHash.equals(prevHash)) {\n            if (this._header.height !== predecessor.header.height + 1) {\n                Log.v(Block, 'No interlink successor - immediate height');\n                return false;\n            }\n\n            const interlink = await predecessor.getNextInterlink(this.target, this.version);\n            const interlinkHash = interlink.hash();\n            if (!this._header.interlinkHash.equals(interlinkHash)) {\n                Log.v(Block, 'No interlink successor - immediate interlink');\n                return false;\n            }\n        }\n        // Otherwise, if the prevHash doesn't match but the blocks should be adjacent according to their height fields,\n        // this cannot be a valid successor of predecessor.\n        else if (this._header.height === predecessor.header.height + 1) {\n            Log.v(Block, 'No interlink successor - immediate height (2)');\n            return false;\n        }\n        // Otherwise, check that the interlink construction is valid given the information we have.\n        else {\n            // TODO Take different targets into account.\n\n            // The number of new blocks in the interlink is bounded by the height difference.\n            /** @type {HashSet.<Hash>} */\n            const hashes = new HashSet();\n            hashes.addAll(this._interlink.hashes);\n            hashes.removeAll(predecessor.interlink.hashes);\n            if (hashes.length > this._header.height - predecessor.header.height) {\n                Log.v(Block, 'No interlink successor - too many new blocks');\n                return false;\n            }\n\n            // Check that the interlink is not too short.\n            const thisDepth = BlockUtils.getTargetDepth(this.target);\n            const prevDepth = BlockUtils.getTargetDepth(predecessor.target);\n            const depthDiff = thisDepth - prevDepth;\n            if (this._interlink.length < predecessor.interlink.length - depthDiff) {\n                Log.v(Block, 'No interlink successor - interlink too short');\n                return false;\n            }\n\n            // If the same block is found in both interlinks, all blocks at lower depths must be the same in both interlinks.\n            let commonBlock = false;\n            const thisInterlink = this._interlink.hashes;\n            const prevInterlink = predecessor.interlink.hashes;\n            for (let i = 1; i < prevInterlink.length && i - depthDiff < thisInterlink.length; i++) {\n                if (prevInterlink[i].equals(thisInterlink[i - depthDiff])) {\n                    commonBlock = true;\n                } else if (commonBlock) {\n                    Log.v(Block, 'No interlink successor - invalid common suffix');\n                    return false;\n                }\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isSuccessorOf(predecessor) {\n        // TODO Improve this! Lots of duplicate checks.\n        return (await this.isImmediateSuccessorOf(predecessor)) || (await this.isInterlinkSuccessorOf(predecessor));\n    }\n\n    /**\n     * @param {BigNumber} nextTarget\n     * @param {number} [nextVersion]\n     * @returns {Promise.<BlockInterlink>}\n     */\n    async getNextInterlink(nextTarget, nextVersion = BlockHeader.CURRENT_VERSION) {\n        /** @type {Array.<Hash>} */\n        const hashes = [];\n        const hash = this.hash();\n\n        // Compute how many times this blockHash should be included in the next interlink.\n        const thisPowDepth = BlockUtils.getHashDepth(await this.pow());\n        const nextTargetDepth = BlockUtils.getTargetDepth(nextTarget);\n        const numOccurrences = Math.max(thisPowDepth - nextTargetDepth + 1, 0);\n\n        // Push this blockHash numOccurrences times onto the next interlink.\n        for (let i = 0; i < numOccurrences; i++) {\n            hashes.push(hash);\n        }\n\n        // Compute how many blocks to omit from the beginning of this interlink.\n        const thisTargetDepth = BlockUtils.getTargetDepth(this.target);\n        const targetOffset = nextTargetDepth - thisTargetDepth;\n        const interlinkOffset = numOccurrences + targetOffset;\n\n        // Push the remaining hashes from this interlink.\n        for (let i = interlinkOffset; i < this.interlink.length; i++) {\n            hashes.push(this.interlink.hashes[i]);\n        }\n\n        return new BlockInterlink(hashes, hash);\n    }\n\n    /**\n     * @returns {Block}\n     */\n    shallowCopy() {\n        return new Block(this._header, this._interlink, this._body);\n    }\n\n    /**\n     * @param {Block|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Block\n            && this._header.equals(o._header)\n            && this._interlink.equals(o._interlink)\n            && (this._body ? this._body.equals(o._body) : !o._body);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isLight() {\n        return !this._body;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFull() {\n        return !!this._body;\n    }\n\n    /**\n     * @returns {Block}\n     */\n    toLight() {\n        return this.isLight() ? this : new Block(this._header, this._interlink);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @returns {Block}\n     */\n    toFull(body) {\n        return this.isFull() ? this : new Block(this._header, this._interlink, body);\n    }\n\n    /**\n     * @type {BlockHeader}\n     */\n    get header() {\n        return this._header;\n    }\n\n    /**\n     * @type {BlockInterlink}\n     */\n    get interlink() {\n        return this._interlink;\n    }\n\n    /**\n     * @type {BlockBody}\n     */\n    get body() {\n        if (this.isLight()) {\n            throw new Error('Cannot access body of light block');\n        }\n        return this._body;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get version() {\n        return this._header.version;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get prevHash() {\n        return this._header.prevHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get interlinkHash() {\n        return this._header.interlinkHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get bodyHash() {\n        return this._header.bodyHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get accountsHash() {\n        return this._header.accountsHash;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nBits() {\n        return this._header.nBits;\n    }\n\n    /**\n     * @type {BigNumber}\n     */\n    get target() {\n        return this._header.target;\n    }\n\n    /**\n     * @type {BigNumber}\n     */\n    get difficulty() {\n        return this._header.difficulty;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this._header.height;\n    }\n\n    /**\n     * @type {number}\n     */\n    get timestamp() {\n        return this._header.timestamp;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nonce() {\n        return this._header.nonce;\n    }\n\n    /**\n     * @type {Address}\n     */\n    get minerAddr() {\n        return this._body ? this._body.minerAddr : undefined;\n    }\n\n    /**\n     * @type {?Array.<Transaction>}\n     */\n    get transactions() {\n        return this._body ? this._body.transactions : undefined;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get extraData() {\n        return this._body ? this._body.extraData : undefined;\n    }\n\n    /**\n     * @returns {?Array.<PrunedAccount>}\n     */\n    get prunedAccounts() {\n        return this._body ? this._body.prunedAccounts : undefined;\n    }\n\n    /**\n     * @type {?number}\n     */\n    get transactionCount() {\n        return this._body ? this._body.transactionCount : undefined;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Hash}\n     */\n    hash(buf) {\n        return this._header.hash(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    pow(buf) {\n        return this._header.pow(buf);\n    }\n\n    /**\n     * @param {Block|object|string} block\n     */\n    static fromAny(block) {\n        if (block instanceof Block) return block;\n        if (typeof block === 'object') return Block.fromPlain(block);\n        if (typeof block === 'string') return Block.unserialize(BufferUtils.fromHex(block));\n        throw new Error('Invalid block');\n    }\n\n    /**\n     * @param {object} plain\n     */\n    static fromPlain(plain) {\n        const header = new BlockHeader(\n            Hash.fromAny(plain.prevHash),\n            Hash.fromAny(plain.interlinkHash),\n            Hash.fromAny(plain.bodyHash),\n            Hash.fromAny(plain.accountsHash),\n            plain.nBits,\n            plain.height,\n            plain.timestamp,\n            plain.nonce,\n            plain.version\n        );\n        const interlink = new BlockInterlink((plain.interlink.hashes || plain.interlink).map(h => Hash.fromAny(h)), Hash.fromAny(plain.prevHash));\n        let body = null;\n        if (plain.minerAddr && plain.extraData !== undefined && Array.isArray(plain.transactions) && Array.isArray(plain.prunedAccounts)) {\n            body = new BlockBody(\n                Address.fromAny(plain.minerAddr),\n                plain.transactions.map(tx => Transaction.fromAny(tx)),\n                BufferUtils.fromAny(plain.extraData),\n                plain.prunedAccounts.map(pa => PrunedAccount.fromAny(pa))\n            );\n        }\n        return new Block(header, interlink, body);\n    }\n\n    toString() {\n        return `Block{height=${this.height},prev=${this.prevHash}}`;\n    }\n\n    toPlain() {\n        const plain = {\n            version: this.version,\n            hash: this.hash().toPlain(),\n            prevHash: this.prevHash.toPlain(),\n            interlinkHash: this.interlinkHash.toPlain(),\n            bodyHash: this.bodyHash.toPlain(),\n            accountsHash: this.accountsHash.toPlain(),\n            nBits: this.nBits,\n            difficulty: this.difficulty.toString(),\n            height: this.height,\n            timestamp: this.timestamp,\n            nonce: this.nonce,\n            interlink: this.interlink.hashes.map(h => h.toPlain()),\n        };\n        if (this.isFull()) {\n            plain.minerAddr = this.minerAddr.toPlain();\n            plain.transactions = this.transactions.map(tx => tx.toPlain());\n            plain.extraData = BufferUtils.toHex(this.extraData);\n            plain.prunedAccounts = this.prunedAccounts.map(pa => pa.toPlain());\n        }\n        return plain;\n    }\n}\n\nBlock.TIMESTAMP_DRIFT_MAX = 600 /* seconds */; // 10 minutes\nClass.register(Block);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId = GenesisConfig.NETWORK_ID) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n        if (!NumberUtils.isUint8(networkId)) throw new Error('Malformed networkId');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._networkId = networkId;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     */\n    verify(networkId) {\n        if (this._valid === undefined) {\n            this._valid = this._verify(networkId);\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     * @private\n     */\n    _verify(networkId = GenesisConfig.NETWORK_ID) {\n        if (this._networkId !== networkId) {\n            Log.w(Transaction, 'Transaction is not valid in this network', this);\n            return false;\n        }\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._networkId === o._networkId\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}, `\n            + `networkId=${this._networkId}`\n            + `}`;\n    }\n\n    toPlain() {\n        const data = Account.TYPE_MAP.get(this.recipientType).dataToPlain(this.data);\n        data.raw = BufferUtils.toHex(this.data);\n        const proof = Account.TYPE_MAP.get(this.senderType).proofToPlain(this.proof);\n        proof.raw = BufferUtils.toHex(this.proof);\n        return {\n            transactionHash: this.hash().toPlain(),\n            format: Transaction.Format.toString(this._format),\n            sender: this.sender.toPlain(),\n            senderType: Account.Type.toString(this.senderType),\n            recipient: this.recipient.toPlain(),\n            recipientType: Account.Type.toString(this.recipientType),\n            value: this.value,\n            fee: this.fee,\n            feePerByte: this.feePerByte,\n            validityStartHeight: this.validityStartHeight,\n            network: GenesisConfig.networkIdToNetworkName(this.networkId),\n            flags: this.flags,\n            data,\n            proof,\n            size: this.serializedSize,\n            valid: this.verify()\n        };\n    }\n\n    /**\n     * @param {object} plain\n     * @return {Transaction}\n     */\n    static fromPlain(plain) {\n        if (!plain) throw new Error('Invalid transaction format');\n        const format = Transaction.Format.fromAny(plain.format);\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).fromPlain(plain);\n    }\n\n    /**\n     * @param {Transaction|string|object} tx\n     * @returns {Transaction}\n     */\n    static fromAny(tx) {\n        if (tx instanceof Transaction) return tx;\n        if (typeof tx === 'object') return Transaction.fromPlain(tx);\n        if (typeof tx === 'string') return Transaction.unserialize(new SerialBuffer(BufferUtils.fromHex(tx)));\n        throw new Error('Invalid transaction format');\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Transaction.Format} */\n    get format() {\n        return this._format;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get networkId() {\n        return this._networkId;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @param {Transaction.Format} format\n */\nTransaction.Format.toString = function(format) {\n    switch (format) {\n        case Transaction.Format.BASIC: return 'basic';\n        case Transaction.Format.EXTENDED: return 'extended';\n    }\n    throw new Error('Invalid transaction format');\n};\n/**\n * @param {Transaction.Format|string} format\n * @return {Transaction.Format}\n */\nTransaction.Format.fromAny = function(format) {\n    if (typeof format === 'number') return format;\n    switch (format) {\n        case 'basic': return Transaction.Format.BASIC;\n        case 'extended': return Transaction.Format.EXTENDED;\n    }\n    throw new Error('Invalid transaction format');\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction, fromPlain: function(plain:object):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n    \n    static get SINGLE_SIG_SIZE() {\n        return PublicKey.SIZE + new MerklePath([]).serializedSize + Signature.SIZE;\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     * @param {number} [networkId]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize(), networkId);\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId);\n    }\n\n    /**\n     * @param {object} plain\n     * @return {BasicTransaction}\n     */\n    static fromPlain(plain) {\n        if (!plain) throw new Error('Invalid transaction format');\n        return new BasicTransaction(\n            PublicKey.fromAny(plain.proof.publicKey || plain.senderPubKey),\n            Address.fromAny(plain.recipient),\n            plain.value,\n            plain.fee,\n            plain.validityStartHeight,\n            Signature.fromAny(plain.proof.signature || plain.signature),\n            GenesisConfig.networkIdFromAny(plain.network || plain.networkId)\n        );\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0), networkId) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {object} plain\n     * @return {ExtendedTransaction}\n     */\n    static fromPlain(plain) {\n        if (!plain) throw new Error('Invalid transaction format');\n        return new ExtendedTransaction(\n            Address.fromAny(plain.sender),\n            Account.Type.fromAny(plain.senderType),\n            Address.fromAny(plain.recipient),\n            Account.Type.fromAny(plain.recipientType),\n            plain.value,\n            plain.fee,\n            plain.validityStartHeight,\n            plain.flags,\n            BufferUtils.fromAny(plain.data.raw === undefined ? plain.data : plain.data.raw),\n            BufferUtils.fromAny(plain.proof.raw === undefined ? plain.proof : plain.proof.raw),\n            GenesisConfig.networkIdFromAny(plain.network || plain.networkId)\n        );\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n"]}